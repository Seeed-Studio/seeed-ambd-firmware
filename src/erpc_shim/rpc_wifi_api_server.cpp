/*
 * Generated by erpcgen 1.7.4 on Wed Oct 14 16:15:46 2020.
 *
 * AUTOGENERATED - DO NOT EDIT
 */


#include "rpc_wifi_api_server.h"
#include <new>
#include "erpc_port.h"
#include "erpc_manually_constructed.h"

#if 10704 != ERPC_VERSION_NUMBER
#error "The generated shim code version is different to the rest of eRPC code."
#endif

using namespace erpc;
using namespace std;

#if ERPC_NESTED_CALLS_DETECTION
extern bool nestingDetection;
#endif

static ManuallyConstructed<rpc_wifi_drv_service> s_rpc_wifi_drv_service;

static ManuallyConstructed<rpc_wifi_tcpip_service> s_rpc_wifi_tcpip_service;


//! @brief Function to read struct binary_t
static void read_binary_t_struct(erpc::Codec * codec, binary_t * data);


// Read struct binary_t function implementation
static void read_binary_t_struct(erpc::Codec * codec, binary_t * data)
{
    uint8_t * data_local;
    codec->readBinary(&data->dataLength, &data_local);
    data->data = (uint8_t *) erpc_malloc(data->dataLength * sizeof(uint8_t));
    if (data->data == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    else
    {
        memcpy(data->data, data_local, data->dataLength);
    }
}


//! @brief Function to write struct binary_t
static void write_binary_t_struct(erpc::Codec * codec, const binary_t * data);


// Write struct binary_t function implementation
static void write_binary_t_struct(erpc::Codec * codec, const binary_t * data)
{
    codec->writeBinary(data->dataLength, data->data);
}


//! @brief Function to free space allocated inside struct binary_t
static void free_binary_t_struct(binary_t * data);


// Free space allocated inside struct binary_t function implementation
static void free_binary_t_struct(binary_t * data)
{
    if (data->data)
    {
        erpc_free(data->data);
    }
}



// Call the correct server shim based on method unique ID.
erpc_status_t rpc_wifi_drv_service::handleInvocation(uint32_t methodId, uint32_t sequence, Codec * codec, MessageBufferFactory *messageFactory)
{
    switch (methodId)
    {
        case krpc_wifi_drv_rpc_wifi_connect_id:
            return rpc_wifi_connect_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_connect_bssid_id:
            return rpc_wifi_connect_bssid_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_disconnect_id:
            return rpc_wifi_disconnect_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_is_connected_to_ap_id:
            return rpc_wifi_is_connected_to_ap_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_is_up_id:
            return rpc_wifi_is_up_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_is_ready_to_transceive_id:
            return rpc_wifi_is_ready_to_transceive_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_mac_address_id:
            return rpc_wifi_set_mac_address_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_get_mac_address_id:
            return rpc_wifi_get_mac_address_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_enable_powersave_id:
            return rpc_wifi_enable_powersave_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_resume_powersave_id:
            return rpc_wifi_resume_powersave_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_disable_powersave_id:
            return rpc_wifi_disable_powersave_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_btcoex_set_bt_on_id:
            return rpc_wifi_btcoex_set_bt_on_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_btcoex_set_bt_off_id:
            return rpc_wifi_btcoex_set_bt_off_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_get_associated_client_list_id:
            return rpc_wifi_get_associated_client_list_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_get_ap_bssid_id:
            return rpc_wifi_get_ap_bssid_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_get_ap_info_id:
            return rpc_wifi_get_ap_info_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_country_id:
            return rpc_wifi_set_country_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_get_sta_max_data_rate_id:
            return rpc_wifi_get_sta_max_data_rate_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_get_rssi_id:
            return rpc_wifi_get_rssi_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_channel_id:
            return rpc_wifi_set_channel_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_get_channel_id:
            return rpc_wifi_get_channel_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_change_channel_plan_id:
            return rpc_wifi_change_channel_plan_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_register_multicast_address_id:
            return rpc_wifi_register_multicast_address_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_unregister_multicast_address_id:
            return rpc_wifi_unregister_multicast_address_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_rf_on_id:
            return rpc_wifi_rf_on_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_rf_off_id:
            return rpc_wifi_rf_off_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_on_id:
            return rpc_wifi_on_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_off_id:
            return rpc_wifi_off_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_mode_id:
            return rpc_wifi_set_mode_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_off_fastly_id:
            return rpc_wifi_off_fastly_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_power_mode_id:
            return rpc_wifi_set_power_mode_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_tdma_param_id:
            return rpc_wifi_set_tdma_param_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_lps_dtim_id:
            return rpc_wifi_set_lps_dtim_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_get_lps_dtim_id:
            return rpc_wifi_get_lps_dtim_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_lps_thresh_id:
            return rpc_wifi_set_lps_thresh_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_lps_level_id:
            return rpc_wifi_set_lps_level_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_mfp_support_id:
            return rpc_wifi_set_mfp_support_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_start_ap_id:
            return rpc_wifi_start_ap_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_start_ap_with_hidden_ssid_id:
            return rpc_wifi_start_ap_with_hidden_ssid_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_pscan_chan_id:
            return rpc_wifi_set_pscan_chan_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_get_setting_id:
            return rpc_wifi_get_setting_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_network_mode_id:
            return rpc_wifi_set_network_mode_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_get_network_mode_id:
            return rpc_wifi_get_network_mode_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_wps_phase_id:
            return rpc_wifi_set_wps_phase_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_restart_ap_id:
            return rpc_wifi_restart_ap_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_config_autoreconnect_id:
            return rpc_wifi_config_autoreconnect_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_autoreconnect_id:
            return rpc_wifi_set_autoreconnect_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_get_autoreconnect_id:
            return rpc_wifi_get_autoreconnect_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_get_last_error_id:
            return rpc_wifi_get_last_error_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_add_custom_ie_id:
            return rpc_wifi_add_custom_ie_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_update_custom_ie_id:
            return rpc_wifi_update_custom_ie_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_del_custom_ie_id:
            return rpc_wifi_del_custom_ie_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_indicate_mgnt_id:
            return rpc_wifi_set_indicate_mgnt_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_get_drv_ability_id:
            return rpc_wifi_get_drv_ability_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_channel_plan_id:
            return rpc_wifi_set_channel_plan_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_get_channel_plan_id:
            return rpc_wifi_get_channel_plan_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_enable_forwarding_id:
            return rpc_wifi_enable_forwarding_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_disable_forwarding_id:
            return rpc_wifi_disable_forwarding_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_ch_deauth_id:
            return rpc_wifi_set_ch_deauth_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_get_band_type_id:
            return rpc_wifi_get_band_type_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_tx_pause_data_id:
            return rpc_wifi_set_tx_pause_data_shim(codec, messageFactory, sequence);

        default:
            return kErpcStatus_InvalidArgument;
    }
}

// Server shim for rpc_wifi_connect of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_connect_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    binary_t *ssid = NULL;
    ssid = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (ssid == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    binary_t *password = NULL;
    password = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (password == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    uint32_t security_type;
    int32_t key_id;
    uint32_t semaphore;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_binary_t_struct(codec, ssid);

    read_binary_t_struct(codec, password);

    codec->read(&security_type);

    codec->read(&key_id);

    codec->read(&semaphore);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_connect(ssid, password, security_type, key_id, semaphore);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_connect_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (ssid)
    {
        free_binary_t_struct(ssid);
    }
    if (ssid)
    {
        erpc_free(ssid);
    }

    if (password)
    {
        free_binary_t_struct(password);
    }
    if (password)
    {
        erpc_free(password);
    }

    return err;
}

// Server shim for rpc_wifi_connect_bssid of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_connect_bssid_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    binary_t *bssid = NULL;
    bssid = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (bssid == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    binary_t *ssid = NULL;
    ssid = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (ssid == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    binary_t *password = NULL;
    password = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (password == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    uint32_t security_type;
    int32_t key_id;
    uint32_t semaphore;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_binary_t_struct(codec, bssid);

    read_binary_t_struct(codec, ssid);

    read_binary_t_struct(codec, password);

    codec->read(&security_type);

    codec->read(&key_id);

    codec->read(&semaphore);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_connect_bssid(bssid, ssid, password, security_type, key_id, semaphore);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_connect_bssid_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (bssid)
    {
        free_binary_t_struct(bssid);
    }
    if (bssid)
    {
        erpc_free(bssid);
    }

    if (ssid)
    {
        free_binary_t_struct(ssid);
    }
    if (ssid)
    {
        erpc_free(ssid);
    }

    if (password)
    {
        free_binary_t_struct(password);
    }
    if (password)
    {
        erpc_free(password);
    }

    return err;
}

// Server shim for rpc_wifi_disconnect of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_disconnect_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_disconnect();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_disconnect_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_is_connected_to_ap of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_is_connected_to_ap_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_is_connected_to_ap();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_is_connected_to_ap_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_is_up of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_is_up_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t itf;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&itf);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_is_up(itf);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_is_up_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_is_ready_to_transceive of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_is_ready_to_transceive_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t itf;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&itf);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_is_ready_to_transceive(itf);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_is_ready_to_transceive_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_set_mac_address of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_mac_address_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    binary_t *mac = NULL;
    mac = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (mac == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_binary_t_struct(codec, mac);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_set_mac_address(mac);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_mac_address_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (mac)
    {
        free_binary_t_struct(mac);
    }
    if (mac)
    {
        erpc_free(mac);
    }

    return err;
}

// Server shim for rpc_wifi_get_mac_address of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_get_mac_address_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t mac[18];
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_get_mac_address(mac);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_get_mac_address_id, sequence);

        for (uint32_t arrayCount0 = 0; arrayCount0 < 18; ++arrayCount0)
        {
            codec->write(mac[arrayCount0]);
        }

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_enable_powersave of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_enable_powersave_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_enable_powersave();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_enable_powersave_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_resume_powersave of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_resume_powersave_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_resume_powersave();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_resume_powersave_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_disable_powersave of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_disable_powersave_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_disable_powersave();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_disable_powersave_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_btcoex_set_bt_on of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_btcoex_set_bt_on_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;


    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        rpc_wifi_btcoex_set_bt_on();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_btcoex_set_bt_on_id, sequence);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_btcoex_set_bt_off of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_btcoex_set_bt_off_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;


    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        rpc_wifi_btcoex_set_bt_off();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_btcoex_set_bt_off_id, sequence);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_get_associated_client_list of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_get_associated_client_list_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    binary_t *client_list_buffer = NULL;
    uint16_t buffer_length;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&buffer_length);

    client_list_buffer = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (client_list_buffer == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_get_associated_client_list(client_list_buffer, buffer_length);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_get_associated_client_list_id, sequence);

        write_binary_t_struct(codec, client_list_buffer);

        codec->write(result);

        err = codec->getStatus();
    }

    if (client_list_buffer)
    {
        free_binary_t_struct(client_list_buffer);
    }
    if (client_list_buffer)
    {
        erpc_free(client_list_buffer);
    }

    return err;
}

// Server shim for rpc_wifi_get_ap_bssid of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_get_ap_bssid_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t bssid[6];
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_get_ap_bssid(bssid);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_get_ap_bssid_id, sequence);

        for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
        {
            codec->write(bssid[arrayCount0]);
        }

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_get_ap_info of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_get_ap_info_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    binary_t *ap_info = NULL;
    uint32_t security;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    ap_info = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (ap_info == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_get_ap_info(ap_info, &security);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_get_ap_info_id, sequence);

        write_binary_t_struct(codec, ap_info);

        codec->write(security);

        codec->write(result);

        err = codec->getStatus();
    }

    if (ap_info)
    {
        free_binary_t_struct(ap_info);
    }
    if (ap_info)
    {
        erpc_free(ap_info);
    }

    return err;
}

// Server shim for rpc_wifi_set_country of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_country_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t country_code;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&country_code);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_set_country(country_code);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_country_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_get_sta_max_data_rate of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_get_sta_max_data_rate_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t inidata_rate;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_get_sta_max_data_rate(&inidata_rate);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_get_sta_max_data_rate_id, sequence);

        codec->write(inidata_rate);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_get_rssi of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_get_rssi_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t pRSSI;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_get_rssi(&pRSSI);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_get_rssi_id, sequence);

        codec->write(pRSSI);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_set_channel of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_channel_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t channel;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&channel);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_set_channel(channel);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_channel_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_get_channel of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_get_channel_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t channel;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_get_channel(&channel);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_get_channel_id, sequence);

        codec->write(channel);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_change_channel_plan of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_change_channel_plan_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t channel_plan;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&channel_plan);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_change_channel_plan(channel_plan);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_change_channel_plan_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_register_multicast_address of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_register_multicast_address_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t mac[6];
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
    {
        codec->read(&mac[arrayCount0]);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_register_multicast_address(mac);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_register_multicast_address_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_unregister_multicast_address of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_unregister_multicast_address_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t mac[6];
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
    {
        codec->read(&mac[arrayCount0]);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_unregister_multicast_address(mac);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_unregister_multicast_address_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_rf_on of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_rf_on_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_rf_on();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_rf_on_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_rf_off of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_rf_off_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_rf_off();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_rf_off_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_on of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_on_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t mode;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&mode);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_on(mode);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_on_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_off of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_off_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_off();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_off_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_set_mode of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_mode_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t mode;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&mode);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_set_mode(mode);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_mode_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_off_fastly of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_off_fastly_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_off_fastly();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_off_fastly_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_set_power_mode of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_power_mode_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t ips_mode;
    uint8_t lps_mode;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&ips_mode);

    codec->read(&lps_mode);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_set_power_mode(ips_mode, lps_mode);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_power_mode_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_set_tdma_param of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_tdma_param_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t slot_period;
    uint8_t rfon_period_len_1;
    uint8_t rfon_period_len_2;
    uint8_t rfon_period_len_3;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&slot_period);

    codec->read(&rfon_period_len_1);

    codec->read(&rfon_period_len_2);

    codec->read(&rfon_period_len_3);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_set_tdma_param(slot_period, rfon_period_len_1, rfon_period_len_2, rfon_period_len_3);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_tdma_param_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_set_lps_dtim of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_lps_dtim_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t dtim;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&dtim);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_set_lps_dtim(dtim);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_lps_dtim_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_get_lps_dtim of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_get_lps_dtim_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t dtim;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_get_lps_dtim(&dtim);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_get_lps_dtim_id, sequence);

        codec->write(dtim);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_set_lps_thresh of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_lps_thresh_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t mode;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&mode);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_set_lps_thresh(mode);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_lps_thresh_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_set_lps_level of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_lps_level_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t lps_level;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&lps_level);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_set_lps_level(lps_level);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_lps_level_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_set_mfp_support of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_mfp_support_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t value;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&value);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_set_mfp_support(value);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_mfp_support_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_start_ap of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_start_ap_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    binary_t *ssid = NULL;
    ssid = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (ssid == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    binary_t *password = NULL;
    password = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (password == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    uint32_t security_type;
    int32_t channel;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_binary_t_struct(codec, ssid);

    read_binary_t_struct(codec, password);

    codec->read(&security_type);

    codec->read(&channel);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_start_ap(ssid, password, security_type, channel);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_start_ap_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (ssid)
    {
        free_binary_t_struct(ssid);
    }
    if (ssid)
    {
        erpc_free(ssid);
    }

    if (password)
    {
        free_binary_t_struct(password);
    }
    if (password)
    {
        erpc_free(password);
    }

    return err;
}

// Server shim for rpc_wifi_start_ap_with_hidden_ssid of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_start_ap_with_hidden_ssid_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    binary_t *ssid = NULL;
    ssid = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (ssid == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    binary_t *password = NULL;
    password = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (password == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    uint32_t security_type;
    int32_t channel;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_binary_t_struct(codec, ssid);

    read_binary_t_struct(codec, password);

    codec->read(&security_type);

    codec->read(&channel);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_start_ap_with_hidden_ssid(ssid, password, security_type, channel);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_start_ap_with_hidden_ssid_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (ssid)
    {
        free_binary_t_struct(ssid);
    }
    if (ssid)
    {
        erpc_free(ssid);
    }

    if (password)
    {
        free_binary_t_struct(password);
    }
    if (password)
    {
        erpc_free(password);
    }

    return err;
}

// Server shim for rpc_wifi_set_pscan_chan of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_pscan_chan_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    binary_t *channel_list = NULL;
    channel_list = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (channel_list == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    uint8_t pscan_config;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_binary_t_struct(codec, channel_list);

    codec->read(&pscan_config);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_set_pscan_chan(channel_list, pscan_config);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_pscan_chan_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (channel_list)
    {
        free_binary_t_struct(channel_list);
    }
    if (channel_list)
    {
        erpc_free(channel_list);
    }

    return err;
}

// Server shim for rpc_wifi_get_setting of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_get_setting_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    char * ifname = NULL;
    binary_t *pSetting = NULL;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    uint32_t ifname_len;
    char * ifname_local;
    codec->readString(&ifname_len, &ifname_local);
    ifname = (char *) erpc_malloc((ifname_len + 1) * sizeof(char));
    if (ifname == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    else
    {
        memcpy(ifname, ifname_local, ifname_len);
        (ifname)[ifname_len] = 0;
    }

    pSetting = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (pSetting == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_get_setting(ifname, pSetting);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_get_setting_id, sequence);

        write_binary_t_struct(codec, pSetting);

        codec->write(result);

        err = codec->getStatus();
    }

    if (ifname)
    {
        erpc_free(ifname);
    }

    if (pSetting)
    {
        free_binary_t_struct(pSetting);
    }
    if (pSetting)
    {
        erpc_free(pSetting);
    }

    return err;
}

// Server shim for rpc_wifi_set_network_mode of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_network_mode_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t mode;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&mode);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_set_network_mode(mode);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_network_mode_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_get_network_mode of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_get_network_mode_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t pmode;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_get_network_mode(&pmode);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_get_network_mode_id, sequence);

        codec->write(pmode);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_set_wps_phase of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_wps_phase_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t is_trigger_wps;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&is_trigger_wps);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_set_wps_phase(is_trigger_wps);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_wps_phase_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_restart_ap of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_restart_ap_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    binary_t *ssid = NULL;
    ssid = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (ssid == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    binary_t *password = NULL;
    password = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (password == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    uint32_t security_type;
    int32_t channel;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_binary_t_struct(codec, ssid);

    read_binary_t_struct(codec, password);

    codec->read(&security_type);

    codec->read(&channel);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_restart_ap(ssid, password, security_type, channel);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_restart_ap_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (ssid)
    {
        free_binary_t_struct(ssid);
    }
    if (ssid)
    {
        erpc_free(ssid);
    }

    if (password)
    {
        free_binary_t_struct(password);
    }
    if (password)
    {
        erpc_free(password);
    }

    return err;
}

// Server shim for rpc_wifi_config_autoreconnect of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_config_autoreconnect_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t mode;
    uint8_t retry_times;
    uint16_t timeout;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&mode);

    codec->read(&retry_times);

    codec->read(&timeout);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_config_autoreconnect(mode, retry_times, timeout);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_config_autoreconnect_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_set_autoreconnect of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_autoreconnect_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t mode;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&mode);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_set_autoreconnect(mode);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_autoreconnect_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_get_autoreconnect of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_get_autoreconnect_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t mode;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_get_autoreconnect(&mode);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_get_autoreconnect_id, sequence);

        codec->write(mode);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_get_last_error of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_get_last_error_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_get_last_error();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_get_last_error_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_add_custom_ie of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_add_custom_ie_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    binary_t *cus_ie = NULL;
    cus_ie = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (cus_ie == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_binary_t_struct(codec, cus_ie);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_add_custom_ie(cus_ie);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_add_custom_ie_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (cus_ie)
    {
        free_binary_t_struct(cus_ie);
    }
    if (cus_ie)
    {
        erpc_free(cus_ie);
    }

    return err;
}

// Server shim for rpc_wifi_update_custom_ie of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_update_custom_ie_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    binary_t *cus_ie = NULL;
    cus_ie = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (cus_ie == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t ie_index;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_binary_t_struct(codec, cus_ie);

    codec->read(&ie_index);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_update_custom_ie(cus_ie, ie_index);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_update_custom_ie_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (cus_ie)
    {
        free_binary_t_struct(cus_ie);
    }
    if (cus_ie)
    {
        erpc_free(cus_ie);
    }

    return err;
}

// Server shim for rpc_wifi_del_custom_ie of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_del_custom_ie_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_del_custom_ie();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_del_custom_ie_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_set_indicate_mgnt of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_indicate_mgnt_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t enable;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&enable);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        rpc_wifi_set_indicate_mgnt(enable);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_indicate_mgnt_id, sequence);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_get_drv_ability of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_get_drv_ability_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t ability;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_get_drv_ability(&ability);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_get_drv_ability_id, sequence);

        codec->write(ability);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_set_channel_plan of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_channel_plan_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t channel_plan;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&channel_plan);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_set_channel_plan(channel_plan);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_channel_plan_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_get_channel_plan of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_get_channel_plan_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t channel_plan;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_get_channel_plan(&channel_plan);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_get_channel_plan_id, sequence);

        codec->write(channel_plan);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_enable_forwarding of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_enable_forwarding_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_enable_forwarding();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_enable_forwarding_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_disable_forwarding of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_disable_forwarding_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_disable_forwarding();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_disable_forwarding_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_set_ch_deauth of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_ch_deauth_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t enable;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&enable);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_set_ch_deauth(enable);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_ch_deauth_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_get_band_type of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_get_band_type_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_get_band_type();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_get_band_type_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_set_tx_pause_data of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_tx_pause_data_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t NewState;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&NewState);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_set_tx_pause_data(NewState);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_tx_pause_data_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Call the correct server shim based on method unique ID.
erpc_status_t rpc_wifi_tcpip_service::handleInvocation(uint32_t methodId, uint32_t sequence, Codec * codec, MessageBufferFactory *messageFactory)
{
    switch (methodId)
    {
        case krpc_wifi_tcpip_rpc_tcpip_adapter_init_id:
            return rpc_tcpip_adapter_init_shim(codec, messageFactory, sequence);

        case krpc_wifi_tcpip_rpc_tcpip_adapter_sta_start_id:
            return rpc_tcpip_adapter_sta_start_shim(codec, messageFactory, sequence);

        case krpc_wifi_tcpip_rpc_tcpip_adapter_ap_start_id:
            return rpc_tcpip_adapter_ap_start_shim(codec, messageFactory, sequence);

        case krpc_wifi_tcpip_rpc_tcpip_adapter_stop_id:
            return rpc_tcpip_adapter_stop_shim(codec, messageFactory, sequence);

        case krpc_wifi_tcpip_rpc_tcpip_adapter_up_id:
            return rpc_tcpip_adapter_up_shim(codec, messageFactory, sequence);

        case krpc_wifi_tcpip_rpc_tcpip_adapter_down_id:
            return rpc_tcpip_adapter_down_shim(codec, messageFactory, sequence);

        case krpc_wifi_tcpip_rpc_tcpip_adapter_get_ip_info_id:
            return rpc_tcpip_adapter_get_ip_info_shim(codec, messageFactory, sequence);

        case krpc_wifi_tcpip_rpc_tcpip_adapter_set_ip_info_id:
            return rpc_tcpip_adapter_set_ip_info_shim(codec, messageFactory, sequence);

        case krpc_wifi_tcpip_rpc_tcpip_adapter_set_dns_info_id:
            return rpc_tcpip_adapter_set_dns_info_shim(codec, messageFactory, sequence);

        case krpc_wifi_tcpip_rpc_tcpip_adapter_get_dns_info_id:
            return rpc_tcpip_adapter_get_dns_info_shim(codec, messageFactory, sequence);

        case krpc_wifi_tcpip_rpc_tcpip_adapter_dhcps_start_id:
            return rpc_tcpip_adapter_dhcps_start_shim(codec, messageFactory, sequence);

        case krpc_wifi_tcpip_rpc_tcpip_adapter_dhcps_stop_id:
            return rpc_tcpip_adapter_dhcps_stop_shim(codec, messageFactory, sequence);

        case krpc_wifi_tcpip_rpc_tcpip_adapter_dhcpc_start_id:
            return rpc_tcpip_adapter_dhcpc_start_shim(codec, messageFactory, sequence);

        case krpc_wifi_tcpip_rpc_tcpip_adapter_dhcpc_stop_id:
            return rpc_tcpip_adapter_dhcpc_stop_shim(codec, messageFactory, sequence);

        case krpc_wifi_tcpip_rpc_tcpip_adapter_set_hostname_id:
            return rpc_tcpip_adapter_set_hostname_shim(codec, messageFactory, sequence);

        case krpc_wifi_tcpip_rpc_tcpip_adapter_get_hostname_id:
            return rpc_tcpip_adapter_get_hostname_shim(codec, messageFactory, sequence);

        case krpc_wifi_tcpip_rpc_tcpip_adapter_get_mac_id:
            return rpc_tcpip_adapter_get_mac_shim(codec, messageFactory, sequence);

        case krpc_wifi_tcpip_rpc_tcpip_adapter_set_mac_id:
            return rpc_tcpip_adapter_set_mac_shim(codec, messageFactory, sequence);

        default:
            return kErpcStatus_InvalidArgument;
    }
}

// Server shim for rpc_tcpip_adapter_init of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_init_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_init();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_init_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_tcpip_adapter_sta_start of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_sta_start_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    binary_t *mac = NULL;
    mac = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (mac == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    binary_t *ip_info = NULL;
    ip_info = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (ip_info == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_binary_t_struct(codec, mac);

    read_binary_t_struct(codec, ip_info);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_sta_start(mac, ip_info);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_sta_start_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (mac)
    {
        free_binary_t_struct(mac);
    }
    if (mac)
    {
        erpc_free(mac);
    }

    if (ip_info)
    {
        free_binary_t_struct(ip_info);
    }
    if (ip_info)
    {
        erpc_free(ip_info);
    }

    return err;
}

// Server shim for rpc_tcpip_adapter_ap_start of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_ap_start_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    binary_t *mac = NULL;
    mac = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (mac == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    binary_t *ip_info = NULL;
    ip_info = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (ip_info == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_binary_t_struct(codec, mac);

    read_binary_t_struct(codec, ip_info);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_ap_start(mac, ip_info);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_ap_start_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (mac)
    {
        free_binary_t_struct(mac);
    }
    if (mac)
    {
        erpc_free(mac);
    }

    if (ip_info)
    {
        free_binary_t_struct(ip_info);
    }
    if (ip_info)
    {
        erpc_free(ip_info);
    }

    return err;
}

// Server shim for rpc_tcpip_adapter_stop of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_stop_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t tcpip_if;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&tcpip_if);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_stop(tcpip_if);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_stop_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_tcpip_adapter_up of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_up_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t tcpip_if;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&tcpip_if);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_up(tcpip_if);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_up_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_tcpip_adapter_down of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_down_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t tcpip_if;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&tcpip_if);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_down(tcpip_if);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_down_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_tcpip_adapter_get_ip_info of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_get_ip_info_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t tcpip_if;
    binary_t *ip_info = NULL;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&tcpip_if);

    ip_info = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (ip_info == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_get_ip_info(tcpip_if, ip_info);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_get_ip_info_id, sequence);

        write_binary_t_struct(codec, ip_info);

        codec->write(result);

        err = codec->getStatus();
    }

    if (ip_info)
    {
        free_binary_t_struct(ip_info);
    }
    if (ip_info)
    {
        erpc_free(ip_info);
    }

    return err;
}

// Server shim for rpc_tcpip_adapter_set_ip_info of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_set_ip_info_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t tcpip_if;
    binary_t *ip_info = NULL;
    ip_info = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (ip_info == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&tcpip_if);

    read_binary_t_struct(codec, ip_info);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_set_ip_info(tcpip_if, ip_info);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_set_ip_info_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (ip_info)
    {
        free_binary_t_struct(ip_info);
    }
    if (ip_info)
    {
        erpc_free(ip_info);
    }

    return err;
}

// Server shim for rpc_tcpip_adapter_set_dns_info of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_set_dns_info_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t tcpip_if;
    uint32_t dns_type;
    binary_t *dns = NULL;
    dns = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (dns == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&tcpip_if);

    codec->read(&dns_type);

    read_binary_t_struct(codec, dns);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_set_dns_info(tcpip_if, dns_type, dns);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_set_dns_info_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (dns)
    {
        free_binary_t_struct(dns);
    }
    if (dns)
    {
        erpc_free(dns);
    }

    return err;
}

// Server shim for rpc_tcpip_adapter_get_dns_info of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_get_dns_info_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t tcpip_if;
    uint32_t dns_type;
    binary_t *dns = NULL;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&tcpip_if);

    codec->read(&dns_type);

    dns = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (dns == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_get_dns_info(tcpip_if, dns_type, dns);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_get_dns_info_id, sequence);

        write_binary_t_struct(codec, dns);

        codec->write(result);

        err = codec->getStatus();
    }

    if (dns)
    {
        free_binary_t_struct(dns);
    }
    if (dns)
    {
        erpc_free(dns);
    }

    return err;
}

// Server shim for rpc_tcpip_adapter_dhcps_start of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_dhcps_start_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t tcpip_if;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&tcpip_if);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_dhcps_start(tcpip_if);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_dhcps_start_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_tcpip_adapter_dhcps_stop of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_dhcps_stop_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t tcpip_if;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&tcpip_if);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_dhcps_stop(tcpip_if);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_dhcps_stop_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_tcpip_adapter_dhcpc_start of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_dhcpc_start_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t tcpip_if;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&tcpip_if);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_dhcpc_start(tcpip_if);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_dhcpc_start_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_tcpip_adapter_dhcpc_stop of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_dhcpc_stop_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t tcpip_if;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&tcpip_if);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_dhcpc_stop(tcpip_if);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_dhcpc_stop_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_tcpip_adapter_set_hostname of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_set_hostname_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t tcpip_if;
    char * hostname = NULL;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&tcpip_if);

    uint32_t hostname_len;
    char * hostname_local;
    codec->readString(&hostname_len, &hostname_local);
    hostname = (char *) erpc_malloc((hostname_len + 1) * sizeof(char));
    if (hostname == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    else
    {
        memcpy(hostname, hostname_local, hostname_len);
        (hostname)[hostname_len] = 0;
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_set_hostname(tcpip_if, hostname);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_set_hostname_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (hostname)
    {
        erpc_free(hostname);
    }

    return err;
}

// Server shim for rpc_tcpip_adapter_get_hostname of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_get_hostname_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t tcpip_if;
    char * hostname = NULL;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&tcpip_if);

    hostname = (char *) erpc_malloc((32 + 1) * sizeof(char));
    if (hostname == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    else
    {
        hostname[32] = '\0';
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_get_hostname(tcpip_if, hostname);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_get_hostname_id, sequence);

        codec->writeString(strlen(hostname), hostname);

        codec->write(result);

        err = codec->getStatus();
    }

    if (hostname)
    {
        erpc_free(hostname);
    }

    return err;
}

// Server shim for rpc_tcpip_adapter_get_mac of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_get_mac_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t tcpip_if;
    binary_t *mac = NULL;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&tcpip_if);

    mac = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (mac == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_get_mac(tcpip_if, mac);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_get_mac_id, sequence);

        write_binary_t_struct(codec, mac);

        codec->write(result);

        err = codec->getStatus();
    }

    if (mac)
    {
        free_binary_t_struct(mac);
    }
    if (mac)
    {
        erpc_free(mac);
    }

    return err;
}

// Server shim for rpc_tcpip_adapter_set_mac of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_set_mac_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t tcpip_if;
    binary_t *mac = NULL;
    mac = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (mac == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&tcpip_if);

    read_binary_t_struct(codec, mac);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_set_mac(tcpip_if, mac);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_set_mac_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (mac)
    {
        free_binary_t_struct(mac);
    }
    if (mac)
    {
        erpc_free(mac);
    }

    return err;
}

erpc_service_t create_rpc_wifi_drv_service()
{
    s_rpc_wifi_drv_service.construct();
    return s_rpc_wifi_drv_service.get();
}

void destroy_rpc_wifi_drv_service()
{
    s_rpc_wifi_drv_service.destroy();
}

erpc_service_t create_rpc_wifi_tcpip_service()
{
    s_rpc_wifi_tcpip_service.construct();
    return s_rpc_wifi_tcpip_service.get();
}

void destroy_rpc_wifi_tcpip_service()
{
    s_rpc_wifi_tcpip_service.destroy();
}
