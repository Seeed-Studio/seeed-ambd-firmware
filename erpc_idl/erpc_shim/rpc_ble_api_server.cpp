/*
 * Generated by erpcgen 1.7.4 on Thu Oct 15 10:46:56 2020.
 *
 * AUTOGENERATED - DO NOT EDIT
 */


#include "rpc_ble_api_server.h"
#include <new>
#include "erpc_port.h"
#include "erpc_manually_constructed.h"

#if 10704 != ERPC_VERSION_NUMBER
#error "The generated shim code version is different to the rest of eRPC code."
#endif

using namespace erpc;
using namespace std;

#if ERPC_NESTED_CALLS_DETECTION
extern bool nestingDetection;
#endif

static ManuallyConstructed<rpc_ble_host_service> s_rpc_ble_host_service;

static ManuallyConstructed<rpc_gap_service> s_rpc_gap_service;

static ManuallyConstructed<rpc_gap_bone_service> s_rpc_gap_bone_service;

static ManuallyConstructed<rpc_gap_le_service> s_rpc_gap_le_service;

static ManuallyConstructed<rpc_gap_config_service> s_rpc_gap_config_service;

static ManuallyConstructed<rpc_gap_adv_service> s_rpc_gap_adv_service;

static ManuallyConstructed<rpc_gap_scan_service> s_rpc_gap_scan_service;

static ManuallyConstructed<rpc_gap_conn_service> s_rpc_gap_conn_service;

static ManuallyConstructed<rpc_gap_storage_service> s_rpc_gap_storage_service;

static ManuallyConstructed<rpc_gatt_client_service> s_rpc_gatt_client_service;

static ManuallyConstructed<rpc_gatt_server_service> s_rpc_gatt_server_service;


//! @brief Function to read struct binary_t
static void read_binary_t_struct(erpc::Codec * codec, binary_t * data);

//! @brief Function to read struct RPC_T_GAP_LE_CONN_REQ_PARAM
static void read_RPC_T_GAP_LE_CONN_REQ_PARAM_struct(erpc::Codec * codec, RPC_T_GAP_LE_CONN_REQ_PARAM * data);

//! @brief Function to read struct RPC_T_LOCAL_NAME
static void read_RPC_T_LOCAL_NAME_struct(erpc::Codec * codec, RPC_T_LOCAL_NAME * data);

//! @brief Function to read struct RPC_T_LOCAL_APPEARANCE
static void read_RPC_T_LOCAL_APPEARANCE_struct(erpc::Codec * codec, RPC_T_LOCAL_APPEARANCE * data);

//! @brief Function to read struct RPC_T_LE_REMOTE_BD
static void read_RPC_T_LE_REMOTE_BD_struct(erpc::Codec * codec, RPC_T_LE_REMOTE_BD * data);

//! @brief Function to read struct RPC_T_LE_KEY_ENTRY
static void read_RPC_T_LE_KEY_ENTRY_struct(erpc::Codec * codec, RPC_T_LE_KEY_ENTRY * data);

//! @brief Function to read struct RPC_T_LE_CCCD
static void read_RPC_T_LE_CCCD_struct(erpc::Codec * codec, RPC_T_LE_CCCD * data);


// Read struct binary_t function implementation
static void read_binary_t_struct(erpc::Codec * codec, binary_t * data)
{
    uint8_t * data_local;
    codec->readBinary(&data->dataLength, &data_local);
    data->data = (uint8_t *) erpc_malloc(data->dataLength * sizeof(uint8_t));
    if (data->data == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    else
    {
        memcpy(data->data, data_local, data->dataLength);
    }
}

// Read struct RPC_T_GAP_LE_CONN_REQ_PARAM function implementation
static void read_RPC_T_GAP_LE_CONN_REQ_PARAM_struct(erpc::Codec * codec, RPC_T_GAP_LE_CONN_REQ_PARAM * data)
{
    codec->read(&data->scan_interval);

    codec->read(&data->scan_window);

    codec->read(&data->conn_interval_min);

    codec->read(&data->conn_interval_max);

    codec->read(&data->conn_latency);

    codec->read(&data->supv_tout);

    codec->read(&data->ce_len_min);

    codec->read(&data->ce_len_max);
}

// Read struct RPC_T_LOCAL_NAME function implementation
static void read_RPC_T_LOCAL_NAME_struct(erpc::Codec * codec, RPC_T_LOCAL_NAME * data)
{
    for (uint32_t arrayCount0 = 0; arrayCount0 < 40; ++arrayCount0)
    {
        codec->read(&data->local_name[arrayCount0]);
    }
}

// Read struct RPC_T_LOCAL_APPEARANCE function implementation
static void read_RPC_T_LOCAL_APPEARANCE_struct(erpc::Codec * codec, RPC_T_LOCAL_APPEARANCE * data)
{
    codec->read(&data->local_appearance);

    for (uint32_t arrayCount0 = 0; arrayCount0 < 2; ++arrayCount0)
    {
        codec->read(&data->padding[arrayCount0]);
    }
}

// Read struct RPC_T_LE_REMOTE_BD function implementation
static void read_RPC_T_LE_REMOTE_BD_struct(erpc::Codec * codec, RPC_T_LE_REMOTE_BD * data)
{
    for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
    {
        codec->read(&data->addr[arrayCount0]);
    }

    codec->read(&data->remote_bd_type);

    codec->read(&data->bond_flags);
}

// Read struct RPC_T_LE_KEY_ENTRY function implementation
static void read_RPC_T_LE_KEY_ENTRY_struct(erpc::Codec * codec, RPC_T_LE_KEY_ENTRY * data)
{
    codec->read(&data->is_used);

    codec->read(&data->idx);

    codec->read(&data->flags);

    codec->read(&data->local_bd_type);

    codec->read(&data->app_data);

    for (uint32_t arrayCount0 = 0; arrayCount0 < 2; ++arrayCount0)
    {
        codec->read(&data->reserved[arrayCount0]);
    }

    read_RPC_T_LE_REMOTE_BD_struct(codec, &(data->remote_bd));

    read_RPC_T_LE_REMOTE_BD_struct(codec, &(data->resolved_remote_bd));
}

// Read struct RPC_T_LE_CCCD function implementation
static void read_RPC_T_LE_CCCD_struct(erpc::Codec * codec, RPC_T_LE_CCCD * data)
{
    codec->read(&data->data_length);

    for (uint32_t arrayCount0 = 0; arrayCount0 < 3; ++arrayCount0)
    {
        codec->read(&data->padding[arrayCount0]);
    }

    codec->read(&data->data);
}


//! @brief Function to write struct binary_t
static void write_binary_t_struct(erpc::Codec * codec, const binary_t * data);

//! @brief Function to write struct RPC_T_GAP_CONN_INFO
static void write_RPC_T_GAP_CONN_INFO_struct(erpc::Codec * codec, const RPC_T_GAP_CONN_INFO * data);

//! @brief Function to write struct RPC_T_LOCAL_NAME
static void write_RPC_T_LOCAL_NAME_struct(erpc::Codec * codec, const RPC_T_LOCAL_NAME * data);

//! @brief Function to write struct RPC_T_LOCAL_APPEARANCE
static void write_RPC_T_LOCAL_APPEARANCE_struct(erpc::Codec * codec, const RPC_T_LOCAL_APPEARANCE * data);

//! @brief Function to write struct RPC_T_LE_REMOTE_BD
static void write_RPC_T_LE_REMOTE_BD_struct(erpc::Codec * codec, const RPC_T_LE_REMOTE_BD * data);

//! @brief Function to write struct RPC_T_LE_KEY_ENTRY
static void write_RPC_T_LE_KEY_ENTRY_struct(erpc::Codec * codec, const RPC_T_LE_KEY_ENTRY * data);

//! @brief Function to write struct RPC_T_LE_CCCD
static void write_RPC_T_LE_CCCD_struct(erpc::Codec * codec, const RPC_T_LE_CCCD * data);


// Write struct binary_t function implementation
static void write_binary_t_struct(erpc::Codec * codec, const binary_t * data)
{
    codec->writeBinary(data->dataLength, data->data);
}

// Write struct RPC_T_GAP_CONN_INFO function implementation
static void write_RPC_T_GAP_CONN_INFO_struct(erpc::Codec * codec, const RPC_T_GAP_CONN_INFO * data)
{
    codec->write(static_cast<int32_t>(data->conn_state));

    codec->write(static_cast<int32_t>(data->role));

    for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
    {
        codec->write(data->remote_bd[arrayCount0]);
    }

    codec->write(data->remote_bd_type);
}

// Write struct RPC_T_LOCAL_NAME function implementation
static void write_RPC_T_LOCAL_NAME_struct(erpc::Codec * codec, const RPC_T_LOCAL_NAME * data)
{
    for (uint32_t arrayCount0 = 0; arrayCount0 < 40; ++arrayCount0)
    {
        codec->write(data->local_name[arrayCount0]);
    }
}

// Write struct RPC_T_LOCAL_APPEARANCE function implementation
static void write_RPC_T_LOCAL_APPEARANCE_struct(erpc::Codec * codec, const RPC_T_LOCAL_APPEARANCE * data)
{
    codec->write(data->local_appearance);

    for (uint32_t arrayCount0 = 0; arrayCount0 < 2; ++arrayCount0)
    {
        codec->write(data->padding[arrayCount0]);
    }
}

// Write struct RPC_T_LE_REMOTE_BD function implementation
static void write_RPC_T_LE_REMOTE_BD_struct(erpc::Codec * codec, const RPC_T_LE_REMOTE_BD * data)
{
    for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
    {
        codec->write(data->addr[arrayCount0]);
    }

    codec->write(data->remote_bd_type);

    codec->write(data->bond_flags);
}

// Write struct RPC_T_LE_KEY_ENTRY function implementation
static void write_RPC_T_LE_KEY_ENTRY_struct(erpc::Codec * codec, const RPC_T_LE_KEY_ENTRY * data)
{
    codec->write(data->is_used);

    codec->write(data->idx);

    codec->write(data->flags);

    codec->write(data->local_bd_type);

    codec->write(data->app_data);

    for (uint32_t arrayCount0 = 0; arrayCount0 < 2; ++arrayCount0)
    {
        codec->write(data->reserved[arrayCount0]);
    }

    write_RPC_T_LE_REMOTE_BD_struct(codec, &(data->remote_bd));

    write_RPC_T_LE_REMOTE_BD_struct(codec, &(data->resolved_remote_bd));
}

// Write struct RPC_T_LE_CCCD function implementation
static void write_RPC_T_LE_CCCD_struct(erpc::Codec * codec, const RPC_T_LE_CCCD * data)
{
    codec->write(data->data_length);

    for (uint32_t arrayCount0 = 0; arrayCount0 < 3; ++arrayCount0)
    {
        codec->write(data->padding[arrayCount0]);
    }

    codec->write(data->data);
}


//! @brief Function to free space allocated inside struct binary_t
static void free_binary_t_struct(binary_t * data);


// Free space allocated inside struct binary_t function implementation
static void free_binary_t_struct(binary_t * data)
{
    if (data->data)
    {
        erpc_free(data->data);
    }
}



// Call the correct server shim based on method unique ID.
erpc_status_t rpc_ble_host_service::handleInvocation(uint32_t methodId, uint32_t sequence, Codec * codec, MessageBufferFactory *messageFactory)
{
    switch (methodId)
    {
        case krpc_ble_host_rpc_ble_init_id:
            return rpc_ble_init_shim(codec, messageFactory, sequence);

        case krpc_ble_host_rpc_ble_start_id:
            return rpc_ble_start_shim(codec, messageFactory, sequence);

        case krpc_ble_host_rpc_ble_deinit_id:
            return rpc_ble_deinit_shim(codec, messageFactory, sequence);

        default:
            return kErpcStatus_InvalidArgument;
    }
}

// Server shim for rpc_ble_init of rpc_ble_host interface.
erpc_status_t rpc_ble_host_service::rpc_ble_init_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    bool result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_ble_init();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_ble_host_service_id, krpc_ble_host_rpc_ble_init_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_ble_start of rpc_ble_host interface.
erpc_status_t rpc_ble_host_service::rpc_ble_start_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;


    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        rpc_ble_start();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_ble_host_service_id, krpc_ble_host_rpc_ble_start_id, sequence);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_ble_deinit of rpc_ble_host interface.
erpc_status_t rpc_ble_host_service::rpc_ble_deinit_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;


    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        rpc_ble_deinit();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_ble_host_service_id, krpc_ble_host_rpc_ble_deinit_id, sequence);

        err = codec->getStatus();
    }

    return err;
}

// Call the correct server shim based on method unique ID.
erpc_status_t rpc_gap_service::handleInvocation(uint32_t methodId, uint32_t sequence, Codec * codec, MessageBufferFactory *messageFactory)
{
    switch (methodId)
    {
        case krpc_gap_rpc_gap_set_param_id:
            return rpc_gap_set_param_shim(codec, messageFactory, sequence);

        case krpc_gap_rpc_gap_get_param_id:
            return rpc_gap_get_param_shim(codec, messageFactory, sequence);

        case krpc_gap_rpc_gap_set_pairable_mode_id:
            return rpc_gap_set_pairable_mode_shim(codec, messageFactory, sequence);

        default:
            return kErpcStatus_InvalidArgument;
    }
}

// Server shim for rpc_gap_set_param of rpc_gap interface.
erpc_status_t rpc_gap_service::rpc_gap_set_param_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_PARAM_TYPE param;
    binary_t *value = NULL;
    value = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (value == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t _tmp_local;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&_tmp_local);
    param = static_cast<RPC_T_GAP_PARAM_TYPE>(_tmp_local);

    read_binary_t_struct(codec, value);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_gap_set_param(param, value);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_service_id, krpc_gap_rpc_gap_set_param_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    if (value)
    {
        free_binary_t_struct(value);
    }
    if (value)
    {
        erpc_free(value);
    }

    return err;
}

// Server shim for rpc_gap_get_param of rpc_gap interface.
erpc_status_t rpc_gap_service::rpc_gap_get_param_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_PARAM_TYPE param;
    binary_t *value = NULL;
    int32_t _tmp_local;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&_tmp_local);
    param = static_cast<RPC_T_GAP_PARAM_TYPE>(_tmp_local);

    value = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (value == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_gap_get_param(param, value);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_service_id, krpc_gap_rpc_gap_get_param_id, sequence);

        write_binary_t_struct(codec, value);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    if (value)
    {
        free_binary_t_struct(value);
    }
    if (value)
    {
        erpc_free(value);
    }

    return err;
}

// Server shim for rpc_gap_set_pairable_mode of rpc_gap interface.
erpc_status_t rpc_gap_service::rpc_gap_set_pairable_mode_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_gap_set_pairable_mode();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_service_id, krpc_gap_rpc_gap_set_pairable_mode_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Call the correct server shim based on method unique ID.
erpc_status_t rpc_gap_bone_service::handleInvocation(uint32_t methodId, uint32_t sequence, Codec * codec, MessageBufferFactory *messageFactory)
{
    switch (methodId)
    {
        case krpc_gap_bone_rpc_le_bond_set_param_id:
            return rpc_le_bond_set_param_shim(codec, messageFactory, sequence);

        case krpc_gap_bone_rpc_le_bond_get_param_id:
            return rpc_le_bond_get_param_shim(codec, messageFactory, sequence);

        case krpc_gap_bone_rpc_le_bond_pair_id:
            return rpc_le_bond_pair_shim(codec, messageFactory, sequence);

        case krpc_gap_bone_rpc_le_bond_get_display_key_id:
            return rpc_le_bond_get_display_key_shim(codec, messageFactory, sequence);

        case krpc_gap_bone_rpc_le_bond_passkey_input_confirm_id:
            return rpc_le_bond_passkey_input_confirm_shim(codec, messageFactory, sequence);

        case krpc_gap_bone_rpc_le_bond_oob_input_confirm_id:
            return rpc_le_bond_oob_input_confirm_shim(codec, messageFactory, sequence);

        case krpc_gap_bone_rpc_le_bond_just_work_confirm_id:
            return rpc_le_bond_just_work_confirm_shim(codec, messageFactory, sequence);

        case krpc_gap_bone_rpc_le_bond_passkey_display_confirm_id:
            return rpc_le_bond_passkey_display_confirm_shim(codec, messageFactory, sequence);

        case krpc_gap_bone_rpc_le_bond_user_confirm_id:
            return rpc_le_bond_user_confirm_shim(codec, messageFactory, sequence);

        case krpc_gap_bone_rpc_le_bond_cfg_local_key_distribute_id:
            return rpc_le_bond_cfg_local_key_distribute_shim(codec, messageFactory, sequence);

        case krpc_gap_bone_rpc_le_bond_clear_all_keys_id:
            return rpc_le_bond_clear_all_keys_shim(codec, messageFactory, sequence);

        case krpc_gap_bone_rpc_le_bond_delete_by_idx_id:
            return rpc_le_bond_delete_by_idx_shim(codec, messageFactory, sequence);

        case krpc_gap_bone_rpc_le_bond_delete_by_bd_id:
            return rpc_le_bond_delete_by_bd_shim(codec, messageFactory, sequence);

        case krpc_gap_bone_rpc_le_bond_get_sec_level_id:
            return rpc_le_bond_get_sec_level_shim(codec, messageFactory, sequence);

        default:
            return kErpcStatus_InvalidArgument;
    }
}

// Server shim for rpc_le_bond_set_param of rpc_gap_bone interface.
erpc_status_t rpc_gap_bone_service::rpc_le_bond_set_param_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_LE_BOND_PARAM_TYPE param;
    binary_t *value = NULL;
    value = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (value == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t _tmp_local;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&_tmp_local);
    param = static_cast<RPC_T_LE_BOND_PARAM_TYPE>(_tmp_local);

    read_binary_t_struct(codec, value);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_bond_set_param(param, value);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_bone_service_id, krpc_gap_bone_rpc_le_bond_set_param_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    if (value)
    {
        free_binary_t_struct(value);
    }
    if (value)
    {
        erpc_free(value);
    }

    return err;
}

// Server shim for rpc_le_bond_get_param of rpc_gap_bone interface.
erpc_status_t rpc_gap_bone_service::rpc_le_bond_get_param_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_LE_BOND_PARAM_TYPE param;
    binary_t *value = NULL;
    int32_t _tmp_local;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&_tmp_local);
    param = static_cast<RPC_T_LE_BOND_PARAM_TYPE>(_tmp_local);

    value = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (value == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_bond_get_param(param, value);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_bone_service_id, krpc_gap_bone_rpc_le_bond_get_param_id, sequence);

        write_binary_t_struct(codec, value);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    if (value)
    {
        free_binary_t_struct(value);
    }
    if (value)
    {
        erpc_free(value);
    }

    return err;
}

// Server shim for rpc_le_bond_pair of rpc_gap_bone interface.
erpc_status_t rpc_gap_bone_service::rpc_le_bond_pair_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t conn_id;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&conn_id);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_bond_pair(conn_id);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_bone_service_id, krpc_gap_bone_rpc_le_bond_pair_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_bond_get_display_key of rpc_gap_bone interface.
erpc_status_t rpc_gap_bone_service::rpc_le_bond_get_display_key_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t conn_id;
    uint32_t key;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&conn_id);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_bond_get_display_key(conn_id, &key);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_bone_service_id, krpc_gap_bone_rpc_le_bond_get_display_key_id, sequence);

        codec->write(key);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_bond_passkey_input_confirm of rpc_gap_bone interface.
erpc_status_t rpc_gap_bone_service::rpc_le_bond_passkey_input_confirm_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t conn_id;
    uint32_t passcode;
    RPC_T_GAP_CFM_CAUSE cause;
    int32_t _tmp_local;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&conn_id);

    codec->read(&passcode);

    codec->read(&_tmp_local);
    cause = static_cast<RPC_T_GAP_CFM_CAUSE>(_tmp_local);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_bond_passkey_input_confirm(conn_id, passcode, cause);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_bone_service_id, krpc_gap_bone_rpc_le_bond_passkey_input_confirm_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_bond_oob_input_confirm of rpc_gap_bone interface.
erpc_status_t rpc_gap_bone_service::rpc_le_bond_oob_input_confirm_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t conn_id;
    RPC_T_GAP_CFM_CAUSE cause;
    int32_t _tmp_local;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&conn_id);

    codec->read(&_tmp_local);
    cause = static_cast<RPC_T_GAP_CFM_CAUSE>(_tmp_local);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_bond_oob_input_confirm(conn_id, cause);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_bone_service_id, krpc_gap_bone_rpc_le_bond_oob_input_confirm_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_bond_just_work_confirm of rpc_gap_bone interface.
erpc_status_t rpc_gap_bone_service::rpc_le_bond_just_work_confirm_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t conn_id;
    RPC_T_GAP_CFM_CAUSE cause;
    int32_t _tmp_local;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&conn_id);

    codec->read(&_tmp_local);
    cause = static_cast<RPC_T_GAP_CFM_CAUSE>(_tmp_local);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_bond_just_work_confirm(conn_id, cause);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_bone_service_id, krpc_gap_bone_rpc_le_bond_just_work_confirm_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_bond_passkey_display_confirm of rpc_gap_bone interface.
erpc_status_t rpc_gap_bone_service::rpc_le_bond_passkey_display_confirm_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t conn_id;
    RPC_T_GAP_CFM_CAUSE cause;
    int32_t _tmp_local;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&conn_id);

    codec->read(&_tmp_local);
    cause = static_cast<RPC_T_GAP_CFM_CAUSE>(_tmp_local);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_bond_passkey_display_confirm(conn_id, cause);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_bone_service_id, krpc_gap_bone_rpc_le_bond_passkey_display_confirm_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_bond_user_confirm of rpc_gap_bone interface.
erpc_status_t rpc_gap_bone_service::rpc_le_bond_user_confirm_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t conn_id;
    RPC_T_GAP_CFM_CAUSE cause;
    int32_t _tmp_local;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&conn_id);

    codec->read(&_tmp_local);
    cause = static_cast<RPC_T_GAP_CFM_CAUSE>(_tmp_local);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_bond_user_confirm(conn_id, cause);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_bone_service_id, krpc_gap_bone_rpc_le_bond_user_confirm_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_bond_cfg_local_key_distribute of rpc_gap_bone interface.
erpc_status_t rpc_gap_bone_service::rpc_le_bond_cfg_local_key_distribute_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t init_dist;
    uint8_t rsp_dist;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&init_dist);

    codec->read(&rsp_dist);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_bond_cfg_local_key_distribute(init_dist, rsp_dist);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_bone_service_id, krpc_gap_bone_rpc_le_bond_cfg_local_key_distribute_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_bond_clear_all_keys of rpc_gap_bone interface.
erpc_status_t rpc_gap_bone_service::rpc_le_bond_clear_all_keys_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;


    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        rpc_le_bond_clear_all_keys();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_bone_service_id, krpc_gap_bone_rpc_le_bond_clear_all_keys_id, sequence);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_bond_delete_by_idx of rpc_gap_bone interface.
erpc_status_t rpc_gap_bone_service::rpc_le_bond_delete_by_idx_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t idx;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&idx);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_bond_delete_by_idx(idx);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_bone_service_id, krpc_gap_bone_rpc_le_bond_delete_by_idx_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_bond_delete_by_bd of rpc_gap_bone interface.
erpc_status_t rpc_gap_bone_service::rpc_le_bond_delete_by_bd_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t bd_addr[6];
    RPC_T_GAP_REMOTE_ADDR_TYPE bd_type;
    int32_t _tmp_local;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
    {
        codec->read(&bd_addr[arrayCount0]);
    }

    codec->read(&_tmp_local);
    bd_type = static_cast<RPC_T_GAP_REMOTE_ADDR_TYPE>(_tmp_local);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_bond_delete_by_bd(bd_addr, bd_type);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_bone_service_id, krpc_gap_bone_rpc_le_bond_delete_by_bd_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_bond_get_sec_level of rpc_gap_bone interface.
erpc_status_t rpc_gap_bone_service::rpc_le_bond_get_sec_level_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t conn_id;
    RPC_T_GAP_SEC_LEVEL sec_type;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&conn_id);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_bond_get_sec_level(conn_id, &sec_type);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_bone_service_id, krpc_gap_bone_rpc_le_bond_get_sec_level_id, sequence);

        codec->write(static_cast<int32_t>(sec_type));

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Call the correct server shim based on method unique ID.
erpc_status_t rpc_gap_le_service::handleInvocation(uint32_t methodId, uint32_t sequence, Codec * codec, MessageBufferFactory *messageFactory)
{
    switch (methodId)
    {
        case krpc_gap_le_rpc_le_gap_init_id:
            return rpc_le_gap_init_shim(codec, messageFactory, sequence);

        case krpc_gap_le_rpc_le_gap_msg_info_way_id:
            return rpc_le_gap_msg_info_way_shim(codec, messageFactory, sequence);

        case krpc_gap_le_rpc_le_get_max_link_num_id:
            return rpc_le_get_max_link_num_shim(codec, messageFactory, sequence);

        case krpc_gap_le_rpc_le_set_gap_param_id:
            return rpc_le_set_gap_param_shim(codec, messageFactory, sequence);

        case krpc_gap_le_rpc_le_get_gap_param_id:
            return rpc_le_get_gap_param_shim(codec, messageFactory, sequence);

        case krpc_gap_le_rpc_le_modify_white_list_id:
            return rpc_le_modify_white_list_shim(codec, messageFactory, sequence);

        case krpc_gap_le_rpc_le_gen_rand_addr_id:
            return rpc_le_gen_rand_addr_shim(codec, messageFactory, sequence);

        case krpc_gap_le_rpc_le_set_rand_addr_id:
            return rpc_le_set_rand_addr_shim(codec, messageFactory, sequence);

        case krpc_gap_le_rpc_le_cfg_local_identity_address_id:
            return rpc_le_cfg_local_identity_address_shim(codec, messageFactory, sequence);

        case krpc_gap_le_rpc_le_set_host_chann_classif_id:
            return rpc_le_set_host_chann_classif_shim(codec, messageFactory, sequence);

        case krpc_gap_le_rpc_le_write_default_data_len_id:
            return rpc_le_write_default_data_len_shim(codec, messageFactory, sequence);

        default:
            return kErpcStatus_InvalidArgument;
    }
}

// Server shim for rpc_le_gap_init of rpc_gap_le interface.
erpc_status_t rpc_gap_le_service::rpc_le_gap_init_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t link_num;
    bool result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&link_num);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_gap_init(link_num);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_le_service_id, krpc_gap_le_rpc_le_gap_init_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_gap_msg_info_way of rpc_gap_le interface.
erpc_status_t rpc_gap_le_service::rpc_le_gap_msg_info_way_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    bool use_msg;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&use_msg);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        rpc_le_gap_msg_info_way(use_msg);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_le_service_id, krpc_gap_le_rpc_le_gap_msg_info_way_id, sequence);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_get_max_link_num of rpc_gap_le interface.
erpc_status_t rpc_gap_le_service::rpc_le_get_max_link_num_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_get_max_link_num();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_le_service_id, krpc_gap_le_rpc_le_get_max_link_num_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_set_gap_param of rpc_gap_le interface.
erpc_status_t rpc_gap_le_service::rpc_le_set_gap_param_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_LE_PARAM_TYPE param;
    binary_t *value = NULL;
    value = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (value == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t _tmp_local;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&_tmp_local);
    param = static_cast<RPC_T_GAP_LE_PARAM_TYPE>(_tmp_local);

    read_binary_t_struct(codec, value);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_set_gap_param(param, value);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_le_service_id, krpc_gap_le_rpc_le_set_gap_param_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    if (value)
    {
        free_binary_t_struct(value);
    }
    if (value)
    {
        erpc_free(value);
    }

    return err;
}

// Server shim for rpc_le_get_gap_param of rpc_gap_le interface.
erpc_status_t rpc_gap_le_service::rpc_le_get_gap_param_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_LE_PARAM_TYPE param;
    binary_t *value = NULL;
    int32_t _tmp_local;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&_tmp_local);
    param = static_cast<RPC_T_GAP_LE_PARAM_TYPE>(_tmp_local);

    value = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (value == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_get_gap_param(param, value);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_le_service_id, krpc_gap_le_rpc_le_get_gap_param_id, sequence);

        write_binary_t_struct(codec, value);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    if (value)
    {
        free_binary_t_struct(value);
    }
    if (value)
    {
        erpc_free(value);
    }

    return err;
}

// Server shim for rpc_le_modify_white_list of rpc_gap_le interface.
erpc_status_t rpc_gap_le_service::rpc_le_modify_white_list_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_WHITE_LIST_OP operation;
    uint8_t bd_addr[6];
    RPC_T_GAP_REMOTE_ADDR_TYPE bd_type;
    int32_t _tmp_local;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&_tmp_local);
    operation = static_cast<RPC_T_GAP_WHITE_LIST_OP>(_tmp_local);

    for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
    {
        codec->read(&bd_addr[arrayCount0]);
    }

    codec->read(&_tmp_local);
    bd_type = static_cast<RPC_T_GAP_REMOTE_ADDR_TYPE>(_tmp_local);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_modify_white_list(operation, bd_addr, bd_type);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_le_service_id, krpc_gap_le_rpc_le_modify_white_list_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_gen_rand_addr of rpc_gap_le interface.
erpc_status_t rpc_gap_le_service::rpc_le_gen_rand_addr_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_RAND_ADDR_TYPE rand_addr_type;
    uint8_t random_bd[6];
    int32_t _tmp_local;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&_tmp_local);
    rand_addr_type = static_cast<RPC_T_GAP_RAND_ADDR_TYPE>(_tmp_local);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_gen_rand_addr(rand_addr_type, random_bd);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_le_service_id, krpc_gap_le_rpc_le_gen_rand_addr_id, sequence);

        for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
        {
            codec->write(random_bd[arrayCount0]);
        }

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_set_rand_addr of rpc_gap_le interface.
erpc_status_t rpc_gap_le_service::rpc_le_set_rand_addr_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t random_bd[6];
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
    {
        codec->read(&random_bd[arrayCount0]);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_set_rand_addr(random_bd);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_le_service_id, krpc_gap_le_rpc_le_set_rand_addr_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_cfg_local_identity_address of rpc_gap_le interface.
erpc_status_t rpc_gap_le_service::rpc_le_cfg_local_identity_address_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t addr[6];
    RPC_T_GAP_IDENT_ADDR_TYPE ident_addr_type;
    int32_t _tmp_local;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
    {
        codec->read(&addr[arrayCount0]);
    }

    codec->read(&_tmp_local);
    ident_addr_type = static_cast<RPC_T_GAP_IDENT_ADDR_TYPE>(_tmp_local);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_cfg_local_identity_address(addr, ident_addr_type);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_le_service_id, krpc_gap_le_rpc_le_cfg_local_identity_address_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_set_host_chann_classif of rpc_gap_le interface.
erpc_status_t rpc_gap_le_service::rpc_le_set_host_chann_classif_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t p_channel_map;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&p_channel_map);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_set_host_chann_classif(p_channel_map);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_le_service_id, krpc_gap_le_rpc_le_set_host_chann_classif_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_write_default_data_len of rpc_gap_le interface.
erpc_status_t rpc_gap_le_service::rpc_le_write_default_data_len_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint16_t tx_octets;
    uint16_t tx_time;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&tx_octets);

    codec->read(&tx_time);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_write_default_data_len(tx_octets, tx_time);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_le_service_id, krpc_gap_le_rpc_le_write_default_data_len_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Call the correct server shim based on method unique ID.
erpc_status_t rpc_gap_config_service::handleInvocation(uint32_t methodId, uint32_t sequence, Codec * codec, MessageBufferFactory *messageFactory)
{
    switch (methodId)
    {
        case krpc_gap_config_rpc_gap_config_cccd_not_check_id:
            return rpc_gap_config_cccd_not_check_shim(codec, messageFactory, sequence);

        case krpc_gap_config_rpc_gap_config_ccc_bits_count_id:
            return rpc_gap_config_ccc_bits_count_shim(codec, messageFactory, sequence);

        case krpc_gap_config_rpc_gap_config_max_attribute_table_count_id:
            return rpc_gap_config_max_attribute_table_count_shim(codec, messageFactory, sequence);

        case krpc_gap_config_rpc_gap_config_max_mtu_size_id:
            return rpc_gap_config_max_mtu_size_shim(codec, messageFactory, sequence);

        case krpc_gap_config_rpc_gap_config_bte_pool_size_id:
            return rpc_gap_config_bte_pool_size_shim(codec, messageFactory, sequence);

        case krpc_gap_config_rpc_gap_config_bt_report_buf_num_id:
            return rpc_gap_config_bt_report_buf_num_shim(codec, messageFactory, sequence);

        case krpc_gap_config_rpc_gap_config_le_key_storage_flag_id:
            return rpc_gap_config_le_key_storage_flag_shim(codec, messageFactory, sequence);

        case krpc_gap_config_rpc_gap_config_max_le_paired_device_id:
            return rpc_gap_config_max_le_paired_device_shim(codec, messageFactory, sequence);

        case krpc_gap_config_rpc_gap_config_max_le_link_num_id:
            return rpc_gap_config_max_le_link_num_shim(codec, messageFactory, sequence);

        default:
            return kErpcStatus_InvalidArgument;
    }
}

// Server shim for rpc_gap_config_cccd_not_check of rpc_gap_config interface.
erpc_status_t rpc_gap_config_service::rpc_gap_config_cccd_not_check_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CONFIG_GATT_CCCD_NOT_CHECK cccd_not_check_flag;
    int32_t _tmp_local;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&_tmp_local);
    cccd_not_check_flag = static_cast<RPC_T_GAP_CONFIG_GATT_CCCD_NOT_CHECK>(_tmp_local);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        rpc_gap_config_cccd_not_check(cccd_not_check_flag);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_config_service_id, krpc_gap_config_rpc_gap_config_cccd_not_check_id, sequence);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_gap_config_ccc_bits_count of rpc_gap_config interface.
erpc_status_t rpc_gap_config_service::rpc_gap_config_ccc_bits_count_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t gatt_server_ccc_bits_count;
    uint8_t gatt_storage_ccc_bits_count;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&gatt_server_ccc_bits_count);

    codec->read(&gatt_storage_ccc_bits_count);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        rpc_gap_config_ccc_bits_count(gatt_server_ccc_bits_count, gatt_storage_ccc_bits_count);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_config_service_id, krpc_gap_config_rpc_gap_config_ccc_bits_count_id, sequence);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_gap_config_max_attribute_table_count of rpc_gap_config interface.
erpc_status_t rpc_gap_config_service::rpc_gap_config_max_attribute_table_count_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t gatt_max_attribute_table_count;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&gatt_max_attribute_table_count);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        rpc_gap_config_max_attribute_table_count(gatt_max_attribute_table_count);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_config_service_id, krpc_gap_config_rpc_gap_config_max_attribute_table_count_id, sequence);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_gap_config_max_mtu_size of rpc_gap_config interface.
erpc_status_t rpc_gap_config_service::rpc_gap_config_max_mtu_size_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint16_t att_max_mtu_size;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&att_max_mtu_size);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        rpc_gap_config_max_mtu_size(att_max_mtu_size);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_config_service_id, krpc_gap_config_rpc_gap_config_max_mtu_size_id, sequence);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_gap_config_bte_pool_size of rpc_gap_config interface.
erpc_status_t rpc_gap_config_service::rpc_gap_config_bte_pool_size_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t bte_pool_size;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&bte_pool_size);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        rpc_gap_config_bte_pool_size(bte_pool_size);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_config_service_id, krpc_gap_config_rpc_gap_config_bte_pool_size_id, sequence);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_gap_config_bt_report_buf_num of rpc_gap_config interface.
erpc_status_t rpc_gap_config_service::rpc_gap_config_bt_report_buf_num_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t bt_report_buf_num;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&bt_report_buf_num);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        rpc_gap_config_bt_report_buf_num(bt_report_buf_num);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_config_service_id, krpc_gap_config_rpc_gap_config_bt_report_buf_num_id, sequence);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_gap_config_le_key_storage_flag of rpc_gap_config interface.
erpc_status_t rpc_gap_config_service::rpc_gap_config_le_key_storage_flag_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint16_t le_key_storage_flag;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&le_key_storage_flag);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        rpc_gap_config_le_key_storage_flag(le_key_storage_flag);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_config_service_id, krpc_gap_config_rpc_gap_config_le_key_storage_flag_id, sequence);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_gap_config_max_le_paired_device of rpc_gap_config interface.
erpc_status_t rpc_gap_config_service::rpc_gap_config_max_le_paired_device_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t max_le_paired_device;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&max_le_paired_device);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        rpc_gap_config_max_le_paired_device(max_le_paired_device);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_config_service_id, krpc_gap_config_rpc_gap_config_max_le_paired_device_id, sequence);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_gap_config_max_le_link_num of rpc_gap_config interface.
erpc_status_t rpc_gap_config_service::rpc_gap_config_max_le_link_num_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t le_link_num;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&le_link_num);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        rpc_gap_config_max_le_link_num(le_link_num);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_config_service_id, krpc_gap_config_rpc_gap_config_max_le_link_num_id, sequence);

        err = codec->getStatus();
    }

    return err;
}

// Call the correct server shim based on method unique ID.
erpc_status_t rpc_gap_adv_service::handleInvocation(uint32_t methodId, uint32_t sequence, Codec * codec, MessageBufferFactory *messageFactory)
{
    switch (methodId)
    {
        case krpc_gap_adv_rpc_le_adv_set_param_id:
            return rpc_le_adv_set_param_shim(codec, messageFactory, sequence);

        case krpc_gap_adv_rpc_le_adv_get_param_id:
            return rpc_le_adv_get_param_shim(codec, messageFactory, sequence);

        case krpc_gap_adv_rpc_le_adv_start_id:
            return rpc_le_adv_start_shim(codec, messageFactory, sequence);

        case krpc_gap_adv_rpc_le_adv_stop_id:
            return rpc_le_adv_stop_shim(codec, messageFactory, sequence);

        case krpc_gap_adv_rpc_le_adv_update_param_id:
            return rpc_le_adv_update_param_shim(codec, messageFactory, sequence);

        default:
            return kErpcStatus_InvalidArgument;
    }
}

// Server shim for rpc_le_adv_set_param of rpc_gap_adv interface.
erpc_status_t rpc_gap_adv_service::rpc_le_adv_set_param_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_LE_ADV_PARAM_TYPE param;
    binary_t *value = NULL;
    value = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (value == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t _tmp_local;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&_tmp_local);
    param = static_cast<RPC_T_LE_ADV_PARAM_TYPE>(_tmp_local);

    read_binary_t_struct(codec, value);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_adv_set_param(param, value);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_adv_service_id, krpc_gap_adv_rpc_le_adv_set_param_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    if (value)
    {
        free_binary_t_struct(value);
    }
    if (value)
    {
        erpc_free(value);
    }

    return err;
}

// Server shim for rpc_le_adv_get_param of rpc_gap_adv interface.
erpc_status_t rpc_gap_adv_service::rpc_le_adv_get_param_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_LE_ADV_PARAM_TYPE param;
    binary_t *value = NULL;
    int32_t _tmp_local;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&_tmp_local);
    param = static_cast<RPC_T_LE_ADV_PARAM_TYPE>(_tmp_local);

    value = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (value == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_adv_get_param(param, value);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_adv_service_id, krpc_gap_adv_rpc_le_adv_get_param_id, sequence);

        write_binary_t_struct(codec, value);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    if (value)
    {
        free_binary_t_struct(value);
    }
    if (value)
    {
        erpc_free(value);
    }

    return err;
}

// Server shim for rpc_le_adv_start of rpc_gap_adv interface.
erpc_status_t rpc_gap_adv_service::rpc_le_adv_start_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_adv_start();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_adv_service_id, krpc_gap_adv_rpc_le_adv_start_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_adv_stop of rpc_gap_adv interface.
erpc_status_t rpc_gap_adv_service::rpc_le_adv_stop_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_adv_stop();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_adv_service_id, krpc_gap_adv_rpc_le_adv_stop_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_adv_update_param of rpc_gap_adv interface.
erpc_status_t rpc_gap_adv_service::rpc_le_adv_update_param_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_adv_update_param();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_adv_service_id, krpc_gap_adv_rpc_le_adv_update_param_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Call the correct server shim based on method unique ID.
erpc_status_t rpc_gap_scan_service::handleInvocation(uint32_t methodId, uint32_t sequence, Codec * codec, MessageBufferFactory *messageFactory)
{
    switch (methodId)
    {
        case krpc_gap_scan_rpc_le_scan_set_param_id:
            return rpc_le_scan_set_param_shim(codec, messageFactory, sequence);

        case krpc_gap_scan_rpc_le_scan_get_param_id:
            return rpc_le_scan_get_param_shim(codec, messageFactory, sequence);

        case krpc_gap_scan_rpc_le_scan_start_id:
            return rpc_le_scan_start_shim(codec, messageFactory, sequence);

        case krpc_gap_scan_rpc_le_scan_timer_start_id:
            return rpc_le_scan_timer_start_shim(codec, messageFactory, sequence);

        case krpc_gap_scan_rpc_le_scan_stop_id:
            return rpc_le_scan_stop_shim(codec, messageFactory, sequence);

        case krpc_gap_scan_rpc_le_scan_info_filter_id:
            return rpc_le_scan_info_filter_shim(codec, messageFactory, sequence);

        default:
            return kErpcStatus_InvalidArgument;
    }
}

// Server shim for rpc_le_scan_set_param of rpc_gap_scan interface.
erpc_status_t rpc_gap_scan_service::rpc_le_scan_set_param_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_LE_SCAN_PARAM_TYPE param;
    binary_t *value = NULL;
    value = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (value == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t _tmp_local;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&_tmp_local);
    param = static_cast<RPC_T_LE_SCAN_PARAM_TYPE>(_tmp_local);

    read_binary_t_struct(codec, value);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_scan_set_param(param, value);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_scan_service_id, krpc_gap_scan_rpc_le_scan_set_param_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    if (value)
    {
        free_binary_t_struct(value);
    }
    if (value)
    {
        erpc_free(value);
    }

    return err;
}

// Server shim for rpc_le_scan_get_param of rpc_gap_scan interface.
erpc_status_t rpc_gap_scan_service::rpc_le_scan_get_param_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_LE_SCAN_PARAM_TYPE param;
    binary_t *value = NULL;
    int32_t _tmp_local;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&_tmp_local);
    param = static_cast<RPC_T_LE_SCAN_PARAM_TYPE>(_tmp_local);

    value = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (value == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_scan_get_param(param, value);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_scan_service_id, krpc_gap_scan_rpc_le_scan_get_param_id, sequence);

        write_binary_t_struct(codec, value);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    if (value)
    {
        free_binary_t_struct(value);
    }
    if (value)
    {
        erpc_free(value);
    }

    return err;
}

// Server shim for rpc_le_scan_start of rpc_gap_scan interface.
erpc_status_t rpc_gap_scan_service::rpc_le_scan_start_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_scan_start();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_scan_service_id, krpc_gap_scan_rpc_le_scan_start_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_scan_timer_start of rpc_gap_scan interface.
erpc_status_t rpc_gap_scan_service::rpc_le_scan_timer_start_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t tick;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&tick);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_scan_timer_start(tick);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_scan_service_id, krpc_gap_scan_rpc_le_scan_timer_start_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_scan_stop of rpc_gap_scan interface.
erpc_status_t rpc_gap_scan_service::rpc_le_scan_stop_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_scan_stop();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_scan_service_id, krpc_gap_scan_rpc_le_scan_stop_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_scan_info_filter of rpc_gap_scan interface.
erpc_status_t rpc_gap_scan_service::rpc_le_scan_info_filter_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    bool enable;
    uint8_t offset;
    uint8_t len;
    uint8_t p_filter[31];
    bool result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&enable);

    codec->read(&offset);

    codec->read(&len);

    for (uint32_t arrayCount0 = 0; arrayCount0 < 31; ++arrayCount0)
    {
        codec->read(&p_filter[arrayCount0]);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_scan_info_filter(enable, offset, len, p_filter);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_scan_service_id, krpc_gap_scan_rpc_le_scan_info_filter_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Call the correct server shim based on method unique ID.
erpc_status_t rpc_gap_conn_service::handleInvocation(uint32_t methodId, uint32_t sequence, Codec * codec, MessageBufferFactory *messageFactory)
{
    switch (methodId)
    {
        case krpc_gap_conn_rpc_le_get_conn_param_id:
            return rpc_le_get_conn_param_shim(codec, messageFactory, sequence);

        case krpc_gap_conn_rpc_le_get_conn_info_id:
            return rpc_le_get_conn_info_shim(codec, messageFactory, sequence);

        case krpc_gap_conn_rpc_le_get_conn_addr_id:
            return rpc_le_get_conn_addr_shim(codec, messageFactory, sequence);

        case krpc_gap_conn_rpc_le_get_conn_id_id:
            return rpc_le_get_conn_id_shim(codec, messageFactory, sequence);

        case krpc_gap_conn_rpc_le_get_active_link_num_id:
            return rpc_le_get_active_link_num_shim(codec, messageFactory, sequence);

        case krpc_gap_conn_rpc_le_get_idle_link_num_id:
            return rpc_le_get_idle_link_num_shim(codec, messageFactory, sequence);

        case krpc_gap_conn_rpc_le_disconnect_id:
            return rpc_le_disconnect_shim(codec, messageFactory, sequence);

        case krpc_gap_conn_rpc_le_read_rssi_id:
            return rpc_le_read_rssi_shim(codec, messageFactory, sequence);

        case krpc_gap_conn_rpc_le_set_data_len_id:
            return rpc_le_set_data_len_shim(codec, messageFactory, sequence);

        case krpc_gap_conn_rpc_le_set_phy_id:
            return rpc_le_set_phy_shim(codec, messageFactory, sequence);

        case krpc_gap_conn_rpc_le_set_conn_param_id:
            return rpc_le_set_conn_param_shim(codec, messageFactory, sequence);

        case krpc_gap_conn_rpc_le_connect_id:
            return rpc_le_connect_shim(codec, messageFactory, sequence);

        case krpc_gap_conn_rpc_le_update_conn_param_id:
            return rpc_le_update_conn_param_shim(codec, messageFactory, sequence);

        default:
            return kErpcStatus_InvalidArgument;
    }
}

// Server shim for rpc_le_get_conn_param of rpc_gap_conn interface.
erpc_status_t rpc_gap_conn_service::rpc_le_get_conn_param_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_LE_CONN_PARAM_TYPE param;
    binary_t *value = NULL;
    uint8_t conn_id;
    int32_t _tmp_local;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&_tmp_local);
    param = static_cast<RPC_T_LE_CONN_PARAM_TYPE>(_tmp_local);

    codec->read(&conn_id);

    value = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (value == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_get_conn_param(param, value, conn_id);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_conn_service_id, krpc_gap_conn_rpc_le_get_conn_param_id, sequence);

        write_binary_t_struct(codec, value);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    if (value)
    {
        free_binary_t_struct(value);
    }
    if (value)
    {
        erpc_free(value);
    }

    return err;
}

// Server shim for rpc_le_get_conn_info of rpc_gap_conn interface.
erpc_status_t rpc_gap_conn_service::rpc_le_get_conn_info_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t conn_id;
    RPC_T_GAP_CONN_INFO *p_conn_info = NULL;
    bool result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&conn_id);

    p_conn_info = (RPC_T_GAP_CONN_INFO *) erpc_malloc(sizeof(RPC_T_GAP_CONN_INFO));
    if (p_conn_info == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_get_conn_info(conn_id, p_conn_info);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_conn_service_id, krpc_gap_conn_rpc_le_get_conn_info_id, sequence);

        write_RPC_T_GAP_CONN_INFO_struct(codec, p_conn_info);

        codec->write(result);

        err = codec->getStatus();
    }

    if (p_conn_info)
    {
        erpc_free(p_conn_info);
    }

    return err;
}

// Server shim for rpc_le_get_conn_addr of rpc_gap_conn interface.
erpc_status_t rpc_gap_conn_service::rpc_le_get_conn_addr_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t conn_id;
    uint8_t bd_addr[6];
    uint8_t bd_type;
    bool result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&conn_id);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_get_conn_addr(conn_id, bd_addr, &bd_type);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_conn_service_id, krpc_gap_conn_rpc_le_get_conn_addr_id, sequence);

        for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
        {
            codec->write(bd_addr[arrayCount0]);
        }

        codec->write(bd_type);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_get_conn_id of rpc_gap_conn interface.
erpc_status_t rpc_gap_conn_service::rpc_le_get_conn_id_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t bd_addr[6];
    uint8_t bd_type;
    uint8_t p_conn_id;
    bool result;

    // startReadMessage() was already called before this shim was invoked.

    for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
    {
        codec->read(&bd_addr[arrayCount0]);
    }

    codec->read(&bd_type);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_get_conn_id(bd_addr, bd_type, &p_conn_id);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_conn_service_id, krpc_gap_conn_rpc_le_get_conn_id_id, sequence);

        codec->write(p_conn_id);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_get_active_link_num of rpc_gap_conn interface.
erpc_status_t rpc_gap_conn_service::rpc_le_get_active_link_num_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_get_active_link_num();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_conn_service_id, krpc_gap_conn_rpc_le_get_active_link_num_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_get_idle_link_num of rpc_gap_conn interface.
erpc_status_t rpc_gap_conn_service::rpc_le_get_idle_link_num_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_get_idle_link_num();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_conn_service_id, krpc_gap_conn_rpc_le_get_idle_link_num_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_disconnect of rpc_gap_conn interface.
erpc_status_t rpc_gap_conn_service::rpc_le_disconnect_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t conn_id;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&conn_id);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_disconnect(conn_id);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_conn_service_id, krpc_gap_conn_rpc_le_disconnect_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_read_rssi of rpc_gap_conn interface.
erpc_status_t rpc_gap_conn_service::rpc_le_read_rssi_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t conn_id;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&conn_id);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_read_rssi(conn_id);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_conn_service_id, krpc_gap_conn_rpc_le_read_rssi_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_set_data_len of rpc_gap_conn interface.
erpc_status_t rpc_gap_conn_service::rpc_le_set_data_len_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t conn_id;
    uint16_t tx_octets;
    uint16_t tx_time;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&conn_id);

    codec->read(&tx_octets);

    codec->read(&tx_time);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_set_data_len(conn_id, tx_octets, tx_time);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_conn_service_id, krpc_gap_conn_rpc_le_set_data_len_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_set_phy of rpc_gap_conn interface.
erpc_status_t rpc_gap_conn_service::rpc_le_set_phy_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t conn_id;
    uint8_t all_phys;
    uint8_t tx_phys;
    uint8_t rx_phys;
    RPC_T_GAP_PHYS_OPTIONS phy_options;
    int32_t _tmp_local;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&conn_id);

    codec->read(&all_phys);

    codec->read(&tx_phys);

    codec->read(&rx_phys);

    codec->read(&_tmp_local);
    phy_options = static_cast<RPC_T_GAP_PHYS_OPTIONS>(_tmp_local);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_set_phy(conn_id, all_phys, tx_phys, rx_phys, phy_options);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_conn_service_id, krpc_gap_conn_rpc_le_set_phy_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_set_conn_param of rpc_gap_conn interface.
erpc_status_t rpc_gap_conn_service::rpc_le_set_conn_param_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CONN_PARAM_TYPE conn_type;
    RPC_T_GAP_LE_CONN_REQ_PARAM *p_conn_param = NULL;
    p_conn_param = (RPC_T_GAP_LE_CONN_REQ_PARAM *) erpc_malloc(sizeof(RPC_T_GAP_LE_CONN_REQ_PARAM));
    if (p_conn_param == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t _tmp_local;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&_tmp_local);
    conn_type = static_cast<RPC_T_GAP_CONN_PARAM_TYPE>(_tmp_local);

    read_RPC_T_GAP_LE_CONN_REQ_PARAM_struct(codec, p_conn_param);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_set_conn_param(conn_type, p_conn_param);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_conn_service_id, krpc_gap_conn_rpc_le_set_conn_param_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    if (p_conn_param)
    {
        erpc_free(p_conn_param);
    }

    return err;
}

// Server shim for rpc_le_connect of rpc_gap_conn interface.
erpc_status_t rpc_gap_conn_service::rpc_le_connect_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t init_phys;
    uint8_t remote_bd[6];
    RPC_T_GAP_REMOTE_ADDR_TYPE remote_bd_type;
    RPC_T_GAP_LOCAL_ADDR_TYPE local_bd_type;
    uint16_t scan_timeout;
    int32_t _tmp_local;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&init_phys);

    for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
    {
        codec->read(&remote_bd[arrayCount0]);
    }

    codec->read(&_tmp_local);
    remote_bd_type = static_cast<RPC_T_GAP_REMOTE_ADDR_TYPE>(_tmp_local);

    codec->read(&_tmp_local);
    local_bd_type = static_cast<RPC_T_GAP_LOCAL_ADDR_TYPE>(_tmp_local);

    codec->read(&scan_timeout);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_connect(init_phys, remote_bd, remote_bd_type, local_bd_type, scan_timeout);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_conn_service_id, krpc_gap_conn_rpc_le_connect_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_update_conn_param of rpc_gap_conn interface.
erpc_status_t rpc_gap_conn_service::rpc_le_update_conn_param_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t conn_id;
    uint16_t conn_interval_min;
    uint16_t conn_interval_max;
    uint16_t conn_latency;
    uint16_t supervision_timeout;
    uint16_t ce_length_min;
    uint16_t ce_length_max;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&conn_id);

    codec->read(&conn_interval_min);

    codec->read(&conn_interval_max);

    codec->read(&conn_latency);

    codec->read(&supervision_timeout);

    codec->read(&ce_length_min);

    codec->read(&ce_length_max);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_update_conn_param(conn_id, conn_interval_min, conn_interval_max, conn_latency, supervision_timeout, ce_length_min, ce_length_max);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_conn_service_id, krpc_gap_conn_rpc_le_update_conn_param_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Call the correct server shim based on method unique ID.
erpc_status_t rpc_gap_storage_service::handleInvocation(uint32_t methodId, uint32_t sequence, Codec * codec, MessageBufferFactory *messageFactory)
{
    switch (methodId)
    {
        case krpc_gap_storage_rpc_flash_save_local_name_id:
            return rpc_flash_save_local_name_shim(codec, messageFactory, sequence);

        case krpc_gap_storage_rpc_flash_load_local_name_id:
            return rpc_flash_load_local_name_shim(codec, messageFactory, sequence);

        case krpc_gap_storage_rpc_flash_save_local_appearance_id:
            return rpc_flash_save_local_appearance_shim(codec, messageFactory, sequence);

        case krpc_gap_storage_rpc_flash_load_local_appearance_id:
            return rpc_flash_load_local_appearance_shim(codec, messageFactory, sequence);

        case krpc_gap_storage_rpc_le_find_key_entry_id:
            return rpc_le_find_key_entry_shim(codec, messageFactory, sequence);

        case krpc_gap_storage_rpc_le_find_key_entry_by_idx_id:
            return rpc_le_find_key_entry_by_idx_shim(codec, messageFactory, sequence);

        case krpc_gap_storage_rpc_le_get_bond_dev_num_id:
            return rpc_le_get_bond_dev_num_shim(codec, messageFactory, sequence);

        case krpc_gap_storage_rpc_le_get_low_priority_bond_id:
            return rpc_le_get_low_priority_bond_shim(codec, messageFactory, sequence);

        case krpc_gap_storage_rpc_le_get_high_priority_bond_id:
            return rpc_le_get_high_priority_bond_shim(codec, messageFactory, sequence);

        case krpc_gap_storage_rpc_le_set_high_priority_bond_id:
            return rpc_le_set_high_priority_bond_shim(codec, messageFactory, sequence);

        case krpc_gap_storage_rpc_le_resolve_random_address_id:
            return rpc_le_resolve_random_address_shim(codec, messageFactory, sequence);

        case krpc_gap_storage_rpc_le_get_cccd_data_id:
            return rpc_le_get_cccd_data_shim(codec, messageFactory, sequence);

        case krpc_gap_storage_rpc_le_gen_bond_dev_id:
            return rpc_le_gen_bond_dev_shim(codec, messageFactory, sequence);

        case krpc_gap_storage_rpc_le_get_dev_bond_info_len_id:
            return rpc_le_get_dev_bond_info_len_shim(codec, messageFactory, sequence);

        case krpc_gap_storage_rpc_le_set_dev_bond_info_id:
            return rpc_le_set_dev_bond_info_shim(codec, messageFactory, sequence);

        case krpc_gap_storage_rpc_le_get_dev_bond_info_id:
            return rpc_le_get_dev_bond_info_shim(codec, messageFactory, sequence);

        default:
            return kErpcStatus_InvalidArgument;
    }
}

// Server shim for rpc_flash_save_local_name of rpc_gap_storage interface.
erpc_status_t rpc_gap_storage_service::rpc_flash_save_local_name_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_LOCAL_NAME *p_data = NULL;
    p_data = (RPC_T_LOCAL_NAME *) erpc_malloc(sizeof(RPC_T_LOCAL_NAME));
    if (p_data == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    uint32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_RPC_T_LOCAL_NAME_struct(codec, p_data);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_flash_save_local_name(p_data);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_storage_service_id, krpc_gap_storage_rpc_flash_save_local_name_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (p_data)
    {
        erpc_free(p_data);
    }

    return err;
}

// Server shim for rpc_flash_load_local_name of rpc_gap_storage interface.
erpc_status_t rpc_gap_storage_service::rpc_flash_load_local_name_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_LOCAL_NAME *p_data = NULL;
    uint32_t result;

    // startReadMessage() was already called before this shim was invoked.

    p_data = (RPC_T_LOCAL_NAME *) erpc_malloc(sizeof(RPC_T_LOCAL_NAME));
    if (p_data == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_flash_load_local_name(p_data);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_storage_service_id, krpc_gap_storage_rpc_flash_load_local_name_id, sequence);

        write_RPC_T_LOCAL_NAME_struct(codec, p_data);

        codec->write(result);

        err = codec->getStatus();
    }

    if (p_data)
    {
        erpc_free(p_data);
    }

    return err;
}

// Server shim for rpc_flash_save_local_appearance of rpc_gap_storage interface.
erpc_status_t rpc_gap_storage_service::rpc_flash_save_local_appearance_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_LOCAL_APPEARANCE *p_data = NULL;
    p_data = (RPC_T_LOCAL_APPEARANCE *) erpc_malloc(sizeof(RPC_T_LOCAL_APPEARANCE));
    if (p_data == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    uint32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_RPC_T_LOCAL_APPEARANCE_struct(codec, p_data);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_flash_save_local_appearance(p_data);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_storage_service_id, krpc_gap_storage_rpc_flash_save_local_appearance_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (p_data)
    {
        erpc_free(p_data);
    }

    return err;
}

// Server shim for rpc_flash_load_local_appearance of rpc_gap_storage interface.
erpc_status_t rpc_gap_storage_service::rpc_flash_load_local_appearance_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_LOCAL_APPEARANCE *p_data = NULL;
    uint32_t result;

    // startReadMessage() was already called before this shim was invoked.

    p_data = (RPC_T_LOCAL_APPEARANCE *) erpc_malloc(sizeof(RPC_T_LOCAL_APPEARANCE));
    if (p_data == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_flash_load_local_appearance(p_data);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_storage_service_id, krpc_gap_storage_rpc_flash_load_local_appearance_id, sequence);

        write_RPC_T_LOCAL_APPEARANCE_struct(codec, p_data);

        codec->write(result);

        err = codec->getStatus();
    }

    if (p_data)
    {
        erpc_free(p_data);
    }

    return err;
}

// Server shim for rpc_le_find_key_entry of rpc_gap_storage interface.
erpc_status_t rpc_gap_storage_service::rpc_le_find_key_entry_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t bd_addr[6];
    RPC_T_GAP_REMOTE_ADDR_TYPE bd_type;
    int32_t _tmp_local;
    RPC_T_LE_KEY_ENTRY * result = NULL;

    // startReadMessage() was already called before this shim was invoked.

    for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
    {
        codec->read(&bd_addr[arrayCount0]);
    }

    codec->read(&_tmp_local);
    bd_type = static_cast<RPC_T_GAP_REMOTE_ADDR_TYPE>(_tmp_local);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_find_key_entry(bd_addr, bd_type);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_storage_service_id, krpc_gap_storage_rpc_le_find_key_entry_id, sequence);

        if (result == NULL)
        {
            codec->writeNullFlag(true);
        }
        else
        {
            codec->writeNullFlag(false);
            write_RPC_T_LE_KEY_ENTRY_struct(codec, result);
        }

        err = codec->getStatus();
    }

    if (result)
    {
        erpc_free(result);
    }

    return err;
}

// Server shim for rpc_le_find_key_entry_by_idx of rpc_gap_storage interface.
erpc_status_t rpc_gap_storage_service::rpc_le_find_key_entry_by_idx_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t idx;
    RPC_T_LE_KEY_ENTRY * result = NULL;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&idx);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_find_key_entry_by_idx(idx);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_storage_service_id, krpc_gap_storage_rpc_le_find_key_entry_by_idx_id, sequence);

        if (result == NULL)
        {
            codec->writeNullFlag(true);
        }
        else
        {
            codec->writeNullFlag(false);
            write_RPC_T_LE_KEY_ENTRY_struct(codec, result);
        }

        err = codec->getStatus();
    }

    if (result)
    {
        erpc_free(result);
    }

    return err;
}

// Server shim for rpc_le_get_bond_dev_num of rpc_gap_storage interface.
erpc_status_t rpc_gap_storage_service::rpc_le_get_bond_dev_num_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_get_bond_dev_num();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_storage_service_id, krpc_gap_storage_rpc_le_get_bond_dev_num_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_get_low_priority_bond of rpc_gap_storage interface.
erpc_status_t rpc_gap_storage_service::rpc_le_get_low_priority_bond_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_LE_KEY_ENTRY * result = NULL;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_get_low_priority_bond();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_storage_service_id, krpc_gap_storage_rpc_le_get_low_priority_bond_id, sequence);

        if (result == NULL)
        {
            codec->writeNullFlag(true);
        }
        else
        {
            codec->writeNullFlag(false);
            write_RPC_T_LE_KEY_ENTRY_struct(codec, result);
        }

        err = codec->getStatus();
    }

    if (result)
    {
        erpc_free(result);
    }

    return err;
}

// Server shim for rpc_le_get_high_priority_bond of rpc_gap_storage interface.
erpc_status_t rpc_gap_storage_service::rpc_le_get_high_priority_bond_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_LE_KEY_ENTRY * result = NULL;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_get_high_priority_bond();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_storage_service_id, krpc_gap_storage_rpc_le_get_high_priority_bond_id, sequence);

        if (result == NULL)
        {
            codec->writeNullFlag(true);
        }
        else
        {
            codec->writeNullFlag(false);
            write_RPC_T_LE_KEY_ENTRY_struct(codec, result);
        }

        err = codec->getStatus();
    }

    if (result)
    {
        erpc_free(result);
    }

    return err;
}

// Server shim for rpc_le_set_high_priority_bond of rpc_gap_storage interface.
erpc_status_t rpc_gap_storage_service::rpc_le_set_high_priority_bond_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t bd_addr[6];
    RPC_T_GAP_REMOTE_ADDR_TYPE bd_type;
    int32_t _tmp_local;
    bool result;

    // startReadMessage() was already called before this shim was invoked.

    for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
    {
        codec->read(&bd_addr[arrayCount0]);
    }

    codec->read(&_tmp_local);
    bd_type = static_cast<RPC_T_GAP_REMOTE_ADDR_TYPE>(_tmp_local);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_set_high_priority_bond(bd_addr, bd_type);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_storage_service_id, krpc_gap_storage_rpc_le_set_high_priority_bond_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_resolve_random_address of rpc_gap_storage interface.
erpc_status_t rpc_gap_storage_service::rpc_le_resolve_random_address_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t unresolved_addr[6];
    uint8_t resolved_addr[6];
    RPC_T_GAP_IDENT_ADDR_TYPE resolved_addr_type;
    int32_t _tmp_local;
    bool result;

    // startReadMessage() was already called before this shim was invoked.

    for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
    {
        codec->read(&unresolved_addr[arrayCount0]);
    }

    for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
    {
        codec->read(&resolved_addr[arrayCount0]);
    }

    codec->read(&_tmp_local);
    resolved_addr_type = static_cast<RPC_T_GAP_IDENT_ADDR_TYPE>(_tmp_local);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_resolve_random_address(unresolved_addr, resolved_addr, &resolved_addr_type);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_storage_service_id, krpc_gap_storage_rpc_le_resolve_random_address_id, sequence);

        for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
        {
            codec->write(resolved_addr[arrayCount0]);
        }

        codec->write(static_cast<int32_t>(resolved_addr_type));

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_get_cccd_data of rpc_gap_storage interface.
erpc_status_t rpc_gap_storage_service::rpc_le_get_cccd_data_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_LE_KEY_ENTRY *p_entry = NULL;
    p_entry = (RPC_T_LE_KEY_ENTRY *) erpc_malloc(sizeof(RPC_T_LE_KEY_ENTRY));
    if (p_entry == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    RPC_T_LE_CCCD *p_data = NULL;
    bool result;

    // startReadMessage() was already called before this shim was invoked.

    read_RPC_T_LE_KEY_ENTRY_struct(codec, p_entry);

    p_data = (RPC_T_LE_CCCD *) erpc_malloc(sizeof(RPC_T_LE_CCCD));
    if (p_data == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_get_cccd_data(p_entry, p_data);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_storage_service_id, krpc_gap_storage_rpc_le_get_cccd_data_id, sequence);

        write_RPC_T_LE_CCCD_struct(codec, p_data);

        codec->write(result);

        err = codec->getStatus();
    }

    if (p_entry)
    {
        erpc_free(p_entry);
    }

    if (p_data)
    {
        erpc_free(p_data);
    }

    return err;
}

// Server shim for rpc_le_gen_bond_dev of rpc_gap_storage interface.
erpc_status_t rpc_gap_storage_service::rpc_le_gen_bond_dev_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t bd_addr[6];
    RPC_T_GAP_REMOTE_ADDR_TYPE bd_type;
    RPC_T_GAP_LOCAL_ADDR_TYPE local_bd_type;
    binary_t *local_ltk = NULL;
    local_ltk = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (local_ltk == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    RPC_T_LE_KEY_TYPE key_type;
    RPC_T_LE_CCCD *p_cccd = NULL;
    p_cccd = (RPC_T_LE_CCCD *) erpc_malloc(sizeof(RPC_T_LE_CCCD));
    if (p_cccd == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t _tmp_local;
    bool result;

    // startReadMessage() was already called before this shim was invoked.

    for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
    {
        codec->read(&bd_addr[arrayCount0]);
    }

    codec->read(&_tmp_local);
    bd_type = static_cast<RPC_T_GAP_REMOTE_ADDR_TYPE>(_tmp_local);

    codec->read(&_tmp_local);
    local_bd_type = static_cast<RPC_T_GAP_LOCAL_ADDR_TYPE>(_tmp_local);

    read_binary_t_struct(codec, local_ltk);

    codec->read(&_tmp_local);
    key_type = static_cast<RPC_T_LE_KEY_TYPE>(_tmp_local);

    read_RPC_T_LE_CCCD_struct(codec, p_cccd);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_gen_bond_dev(bd_addr, bd_type, local_bd_type, local_ltk, key_type, p_cccd);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_storage_service_id, krpc_gap_storage_rpc_le_gen_bond_dev_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (local_ltk)
    {
        free_binary_t_struct(local_ltk);
    }
    if (local_ltk)
    {
        erpc_free(local_ltk);
    }

    if (p_cccd)
    {
        erpc_free(p_cccd);
    }

    return err;
}

// Server shim for rpc_le_get_dev_bond_info_len of rpc_gap_storage interface.
erpc_status_t rpc_gap_storage_service::rpc_le_get_dev_bond_info_len_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint16_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_get_dev_bond_info_len();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_storage_service_id, krpc_gap_storage_rpc_le_get_dev_bond_info_len_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_le_set_dev_bond_info of rpc_gap_storage interface.
erpc_status_t rpc_gap_storage_service::rpc_le_set_dev_bond_info_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    binary_t *p_data = NULL;
    p_data = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (p_data == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    bool exist;
    RPC_T_LE_KEY_ENTRY * result = NULL;

    // startReadMessage() was already called before this shim was invoked.

    read_binary_t_struct(codec, p_data);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_set_dev_bond_info(p_data, &exist);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_storage_service_id, krpc_gap_storage_rpc_le_set_dev_bond_info_id, sequence);

        codec->write(exist);

        if (result == NULL)
        {
            codec->writeNullFlag(true);
        }
        else
        {
            codec->writeNullFlag(false);
            write_RPC_T_LE_KEY_ENTRY_struct(codec, result);
        }

        err = codec->getStatus();
    }

    if (p_data)
    {
        free_binary_t_struct(p_data);
    }
    if (p_data)
    {
        erpc_free(p_data);
    }

    if (result)
    {
        erpc_free(result);
    }

    return err;
}

// Server shim for rpc_le_get_dev_bond_info of rpc_gap_storage interface.
erpc_status_t rpc_gap_storage_service::rpc_le_get_dev_bond_info_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_LE_KEY_ENTRY *p_entry = NULL;
    p_entry = (RPC_T_LE_KEY_ENTRY *) erpc_malloc(sizeof(RPC_T_LE_KEY_ENTRY));
    if (p_entry == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    binary_t *p_data = NULL;
    bool result;

    // startReadMessage() was already called before this shim was invoked.

    read_RPC_T_LE_KEY_ENTRY_struct(codec, p_entry);

    p_data = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (p_data == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_le_get_dev_bond_info(p_entry, p_data);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gap_storage_service_id, krpc_gap_storage_rpc_le_get_dev_bond_info_id, sequence);

        write_binary_t_struct(codec, p_data);

        codec->write(result);

        err = codec->getStatus();
    }

    if (p_entry)
    {
        erpc_free(p_entry);
    }

    if (p_data)
    {
        free_binary_t_struct(p_data);
    }
    if (p_data)
    {
        erpc_free(p_data);
    }

    return err;
}

// Call the correct server shim based on method unique ID.
erpc_status_t rpc_gatt_client_service::handleInvocation(uint32_t methodId, uint32_t sequence, Codec * codec, MessageBufferFactory *messageFactory)
{
    switch (methodId)
    {
        case krpc_gatt_client_rpc_ble_client_init_id:
            return rpc_ble_client_init_shim(codec, messageFactory, sequence);

        case krpc_gatt_client_rpc_ble_add_client_id:
            return rpc_ble_add_client_shim(codec, messageFactory, sequence);

        case krpc_gatt_client_rpc_client_init_id:
            return rpc_client_init_shim(codec, messageFactory, sequence);

        case krpc_gatt_client_rpc_client_all_primary_srv_discovery_id:
            return rpc_client_all_primary_srv_discovery_shim(codec, messageFactory, sequence);

        case krpc_gatt_client_rpc_client_by_uuid_srv_discovery_id:
            return rpc_client_by_uuid_srv_discovery_shim(codec, messageFactory, sequence);

        case krpc_gatt_client_rpc_client_by_uuid128_srv_discovery_id:
            return rpc_client_by_uuid128_srv_discovery_shim(codec, messageFactory, sequence);

        case krpc_gatt_client_rpc_client_relationship_discovery_id:
            return rpc_client_relationship_discovery_shim(codec, messageFactory, sequence);

        case krpc_gatt_client_rpc_client_all_char_discovery_id:
            return rpc_client_all_char_discovery_shim(codec, messageFactory, sequence);

        case krpc_gatt_client_rpc_client_by_uuid_char_discovery_id:
            return rpc_client_by_uuid_char_discovery_shim(codec, messageFactory, sequence);

        case krpc_gatt_client_rpc_client_by_uuid128_char_discovery_id:
            return rpc_client_by_uuid128_char_discovery_shim(codec, messageFactory, sequence);

        case krpc_gatt_client_rpc_client_all_char_descriptor_discovery_id:
            return rpc_client_all_char_descriptor_discovery_shim(codec, messageFactory, sequence);

        case krpc_gatt_client_rpc_client_attr_read_id:
            return rpc_client_attr_read_shim(codec, messageFactory, sequence);

        case krpc_gatt_client_rpc_client_attr_read_using_uuid_id:
            return rpc_client_attr_read_using_uuid_shim(codec, messageFactory, sequence);

        case krpc_gatt_client_rpc_client_attr_write_id:
            return rpc_client_attr_write_shim(codec, messageFactory, sequence);

        case krpc_gatt_client_rpc_client_attr_ind_confirm_id:
            return rpc_client_attr_ind_confirm_shim(codec, messageFactory, sequence);

        default:
            return kErpcStatus_InvalidArgument;
    }
}

// Server shim for rpc_ble_client_init of rpc_gatt_client interface.
erpc_status_t rpc_gatt_client_service::rpc_ble_client_init_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t num;
    bool result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&num);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_ble_client_init(num);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gatt_client_service_id, krpc_gatt_client_rpc_ble_client_init_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_ble_add_client of rpc_gatt_client interface.
erpc_status_t rpc_gatt_client_service::rpc_ble_add_client_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t app_id;
    uint8_t link_num;
    uint8_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&app_id);

    codec->read(&link_num);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_ble_add_client(app_id, link_num);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gatt_client_service_id, krpc_gatt_client_rpc_ble_add_client_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_client_init of rpc_gatt_client interface.
erpc_status_t rpc_gatt_client_service::rpc_client_init_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t client_num;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&client_num);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        rpc_client_init(client_num);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gatt_client_service_id, krpc_gatt_client_rpc_client_init_id, sequence);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_client_all_primary_srv_discovery of rpc_gatt_client interface.
erpc_status_t rpc_gatt_client_service::rpc_client_all_primary_srv_discovery_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t conn_id;
    uint8_t client_id;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&conn_id);

    codec->read(&client_id);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_client_all_primary_srv_discovery(conn_id, client_id);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gatt_client_service_id, krpc_gatt_client_rpc_client_all_primary_srv_discovery_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_client_by_uuid_srv_discovery of rpc_gatt_client interface.
erpc_status_t rpc_gatt_client_service::rpc_client_by_uuid_srv_discovery_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t conn_id;
    uint8_t client_id;
    uint16_t uuid16;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&conn_id);

    codec->read(&client_id);

    codec->read(&uuid16);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_client_by_uuid_srv_discovery(conn_id, client_id, uuid16);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gatt_client_service_id, krpc_gatt_client_rpc_client_by_uuid_srv_discovery_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_client_by_uuid128_srv_discovery of rpc_gatt_client interface.
erpc_status_t rpc_gatt_client_service::rpc_client_by_uuid128_srv_discovery_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t conn_id;
    uint8_t client_id;
    uint8_t p_uuid128[16];
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&conn_id);

    codec->read(&client_id);

    for (uint32_t arrayCount0 = 0; arrayCount0 < 16; ++arrayCount0)
    {
        codec->read(&p_uuid128[arrayCount0]);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_client_by_uuid128_srv_discovery(conn_id, client_id, p_uuid128);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gatt_client_service_id, krpc_gatt_client_rpc_client_by_uuid128_srv_discovery_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_client_relationship_discovery of rpc_gatt_client interface.
erpc_status_t rpc_gatt_client_service::rpc_client_relationship_discovery_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t conn_id;
    uint8_t client_id;
    uint16_t start_handle;
    uint16_t end_handle;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&conn_id);

    codec->read(&client_id);

    codec->read(&start_handle);

    codec->read(&end_handle);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_client_relationship_discovery(conn_id, client_id, start_handle, end_handle);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gatt_client_service_id, krpc_gatt_client_rpc_client_relationship_discovery_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_client_all_char_discovery of rpc_gatt_client interface.
erpc_status_t rpc_gatt_client_service::rpc_client_all_char_discovery_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t conn_id;
    uint8_t client_id;
    uint16_t start_handle;
    uint16_t end_handle;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&conn_id);

    codec->read(&client_id);

    codec->read(&start_handle);

    codec->read(&end_handle);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_client_all_char_discovery(conn_id, client_id, start_handle, end_handle);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gatt_client_service_id, krpc_gatt_client_rpc_client_all_char_discovery_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_client_by_uuid_char_discovery of rpc_gatt_client interface.
erpc_status_t rpc_gatt_client_service::rpc_client_by_uuid_char_discovery_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t conn_id;
    uint8_t client_id;
    uint16_t start_handle;
    uint16_t end_handle;
    uint16_t uuid16;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&conn_id);

    codec->read(&client_id);

    codec->read(&start_handle);

    codec->read(&end_handle);

    codec->read(&uuid16);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_client_by_uuid_char_discovery(conn_id, client_id, start_handle, end_handle, uuid16);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gatt_client_service_id, krpc_gatt_client_rpc_client_by_uuid_char_discovery_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_client_by_uuid128_char_discovery of rpc_gatt_client interface.
erpc_status_t rpc_gatt_client_service::rpc_client_by_uuid128_char_discovery_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t conn_id;
    uint8_t client_id;
    uint16_t start_handle;
    uint16_t end_handle;
    uint8_t p_uuid128[16];
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&conn_id);

    codec->read(&client_id);

    codec->read(&start_handle);

    codec->read(&end_handle);

    for (uint32_t arrayCount0 = 0; arrayCount0 < 16; ++arrayCount0)
    {
        codec->read(&p_uuid128[arrayCount0]);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_client_by_uuid128_char_discovery(conn_id, client_id, start_handle, end_handle, p_uuid128);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gatt_client_service_id, krpc_gatt_client_rpc_client_by_uuid128_char_discovery_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_client_all_char_descriptor_discovery of rpc_gatt_client interface.
erpc_status_t rpc_gatt_client_service::rpc_client_all_char_descriptor_discovery_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t conn_id;
    uint8_t client_id;
    uint16_t start_handle;
    uint16_t end_handle;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&conn_id);

    codec->read(&client_id);

    codec->read(&start_handle);

    codec->read(&end_handle);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_client_all_char_descriptor_discovery(conn_id, client_id, start_handle, end_handle);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gatt_client_service_id, krpc_gatt_client_rpc_client_all_char_descriptor_discovery_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_client_attr_read of rpc_gatt_client interface.
erpc_status_t rpc_gatt_client_service::rpc_client_attr_read_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t conn_id;
    uint8_t client_id;
    uint16_t handle;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&conn_id);

    codec->read(&client_id);

    codec->read(&handle);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_client_attr_read(conn_id, client_id, handle);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gatt_client_service_id, krpc_gatt_client_rpc_client_attr_read_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_client_attr_read_using_uuid of rpc_gatt_client interface.
erpc_status_t rpc_gatt_client_service::rpc_client_attr_read_using_uuid_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t conn_id;
    uint8_t client_id;
    uint16_t start_handle;
    uint16_t end_handle;
    uint16_t uuid16;
    uint8_t p_uuid128[16];
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&conn_id);

    codec->read(&client_id);

    codec->read(&start_handle);

    codec->read(&end_handle);

    codec->read(&uuid16);

    for (uint32_t arrayCount0 = 0; arrayCount0 < 16; ++arrayCount0)
    {
        codec->read(&p_uuid128[arrayCount0]);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_client_attr_read_using_uuid(conn_id, client_id, start_handle, end_handle, uuid16, p_uuid128);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gatt_client_service_id, krpc_gatt_client_rpc_client_attr_read_using_uuid_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_client_attr_write of rpc_gatt_client interface.
erpc_status_t rpc_gatt_client_service::rpc_client_attr_write_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t conn_id;
    uint8_t client_id;
    RPC_T_GATT_WRITE_TYPE write_type;
    uint16_t handle;
    binary_t *data = NULL;
    data = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (data == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t _tmp_local;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&conn_id);

    codec->read(&client_id);

    codec->read(&_tmp_local);
    write_type = static_cast<RPC_T_GATT_WRITE_TYPE>(_tmp_local);

    codec->read(&handle);

    read_binary_t_struct(codec, data);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_client_attr_write(conn_id, client_id, write_type, handle, data);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gatt_client_service_id, krpc_gatt_client_rpc_client_attr_write_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    if (data)
    {
        free_binary_t_struct(data);
    }
    if (data)
    {
        erpc_free(data);
    }

    return err;
}

// Server shim for rpc_client_attr_ind_confirm of rpc_gatt_client interface.
erpc_status_t rpc_gatt_client_service::rpc_client_attr_ind_confirm_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t conn_id;
    RPC_T_GAP_CAUSE result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&conn_id);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_client_attr_ind_confirm(conn_id);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gatt_client_service_id, krpc_gatt_client_rpc_client_attr_ind_confirm_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    return err;
}

// Call the correct server shim based on method unique ID.
erpc_status_t rpc_gatt_server_service::handleInvocation(uint32_t methodId, uint32_t sequence, Codec * codec, MessageBufferFactory *messageFactory)
{
    switch (methodId)
    {
        case krpc_gatt_server_rpc_ble_server_init_id:
            return rpc_ble_server_init_shim(codec, messageFactory, sequence);

        case krpc_gatt_server_rpc_ble_create_service_id:
            return rpc_ble_create_service_shim(codec, messageFactory, sequence);

        case krpc_gatt_server_rpc_ble_delete_service_id:
            return rpc_ble_delete_service_shim(codec, messageFactory, sequence);

        case krpc_gatt_server_rpc_ble_service_start_id:
            return rpc_ble_service_start_shim(codec, messageFactory, sequence);

        case krpc_gatt_server_rpc_ble_get_servie_handle_id:
            return rpc_ble_get_servie_handle_shim(codec, messageFactory, sequence);

        case krpc_gatt_server_rpc_ble_create_char_id:
            return rpc_ble_create_char_shim(codec, messageFactory, sequence);

        case krpc_gatt_server_rpc_ble_create_desc_id:
            return rpc_ble_create_desc_shim(codec, messageFactory, sequence);

        case krpc_gatt_server_rpc_server_send_data_id:
            return rpc_server_send_data_shim(codec, messageFactory, sequence);

        case krpc_gatt_server_rpc_ble_server_get_attr_value_id:
            return rpc_ble_server_get_attr_value_shim(codec, messageFactory, sequence);

        case krpc_gatt_server_rpc_server_exec_write_confirm_id:
            return rpc_server_exec_write_confirm_shim(codec, messageFactory, sequence);

        case krpc_gatt_server_rpc_server_attr_write_confirm_id:
            return rpc_server_attr_write_confirm_shim(codec, messageFactory, sequence);

        case krpc_gatt_server_rpc_server_attr_read_confirm_id:
            return rpc_server_attr_read_confirm_shim(codec, messageFactory, sequence);

        default:
            return kErpcStatus_InvalidArgument;
    }
}

// Server shim for rpc_ble_server_init of rpc_gatt_server interface.
erpc_status_t rpc_gatt_server_service::rpc_ble_server_init_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t num;
    bool result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&num);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_ble_server_init(num);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gatt_server_service_id, krpc_gatt_server_rpc_ble_server_init_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_ble_create_service of rpc_gatt_server interface.
erpc_status_t rpc_gatt_server_service::rpc_ble_create_service_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t uuid[16];
    uint8_t uuid_length;
    bool is_primary;
    uint8_t result;

    // startReadMessage() was already called before this shim was invoked.

    for (uint32_t arrayCount0 = 0; arrayCount0 < 16; ++arrayCount0)
    {
        codec->read(&uuid[arrayCount0]);
    }

    codec->read(&uuid_length);

    codec->read(&is_primary);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_ble_create_service(uuid, uuid_length, is_primary);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gatt_server_service_id, krpc_gatt_server_rpc_ble_create_service_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_ble_delete_service of rpc_gatt_server interface.
erpc_status_t rpc_gatt_server_service::rpc_ble_delete_service_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t app_id;
    bool result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&app_id);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_ble_delete_service(app_id);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gatt_server_service_id, krpc_gatt_server_rpc_ble_delete_service_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_ble_service_start of rpc_gatt_server interface.
erpc_status_t rpc_gatt_server_service::rpc_ble_service_start_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t app_id;
    uint8_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&app_id);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_ble_service_start(app_id);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gatt_server_service_id, krpc_gatt_server_rpc_ble_service_start_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_ble_get_servie_handle of rpc_gatt_server interface.
erpc_status_t rpc_gatt_server_service::rpc_ble_get_servie_handle_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t app_id;
    uint8_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&app_id);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_ble_get_servie_handle(app_id);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gatt_server_service_id, krpc_gatt_server_rpc_ble_get_servie_handle_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_ble_create_char of rpc_gatt_server interface.
erpc_status_t rpc_gatt_server_service::rpc_ble_create_char_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t app_id;
    uint8_t uuid[16];
    uint8_t uuid_length;
    uint8_t properties;
    uint32_t permissions;
    uint16_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&app_id);

    for (uint32_t arrayCount0 = 0; arrayCount0 < 16; ++arrayCount0)
    {
        codec->read(&uuid[arrayCount0]);
    }

    codec->read(&uuid_length);

    codec->read(&properties);

    codec->read(&permissions);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_ble_create_char(app_id, uuid, uuid_length, properties, permissions);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gatt_server_service_id, krpc_gatt_server_rpc_ble_create_char_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_ble_create_desc of rpc_gatt_server interface.
erpc_status_t rpc_gatt_server_service::rpc_ble_create_desc_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t app_id;
    uint16_t char_handle;
    uint8_t uuid[16];
    uint8_t uuid_length;
    uint8_t flags;
    uint32_t permissions;
    uint16_t value_length;
    binary_t *p_value = NULL;
    bool isNull;
    uint16_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&app_id);

    codec->read(&char_handle);

    for (uint32_t arrayCount0 = 0; arrayCount0 < 16; ++arrayCount0)
    {
        codec->read(&uuid[arrayCount0]);
    }

    codec->read(&uuid_length);

    codec->read(&flags);

    codec->read(&permissions);

    codec->read(&value_length);

    codec->readNullFlag(&isNull);
    if (!isNull)
    {
        p_value = (binary_t *) erpc_malloc(sizeof(binary_t));
        if (p_value == NULL)
        {
            codec->updateStatus(kErpcStatus_MemoryError);
        }
        read_binary_t_struct(codec, p_value);
    }
    else
    {
        p_value = NULL;
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_ble_create_desc(app_id, char_handle, uuid, uuid_length, flags, permissions, value_length, p_value);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gatt_server_service_id, krpc_gatt_server_rpc_ble_create_desc_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_server_send_data of rpc_gatt_server interface.
erpc_status_t rpc_gatt_server_service::rpc_server_send_data_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t conn_id;
    uint8_t service_id;
    uint16_t attrib_index;
    binary_t *data = NULL;
    data = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (data == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    RPC_T_GATT_PDU_TYPE pdu_type;
    int32_t _tmp_local;
    bool result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&conn_id);

    codec->read(&service_id);

    codec->read(&attrib_index);

    read_binary_t_struct(codec, data);

    codec->read(&_tmp_local);
    pdu_type = static_cast<RPC_T_GATT_PDU_TYPE>(_tmp_local);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_server_send_data(conn_id, service_id, attrib_index, data, pdu_type);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gatt_server_service_id, krpc_gatt_server_rpc_server_send_data_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (data)
    {
        free_binary_t_struct(data);
    }
    if (data)
    {
        erpc_free(data);
    }

    return err;
}

// Server shim for rpc_ble_server_get_attr_value of rpc_gatt_server interface.
erpc_status_t rpc_gatt_server_service::rpc_ble_server_get_attr_value_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t app_id;
    uint16_t attr_handle;
    binary_t * result = NULL;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&app_id);

    codec->read(&attr_handle);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_ble_server_get_attr_value(app_id, attr_handle);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gatt_server_service_id, krpc_gatt_server_rpc_ble_server_get_attr_value_id, sequence);

        if (result == NULL)
        {
            codec->writeNullFlag(true);
        }
        else
        {
            codec->writeNullFlag(false);
            write_binary_t_struct(codec, result);
        }

        err = codec->getStatus();
    }

    if (result)
    {
        free_binary_t_struct(result);
    }
    if (result)
    {
        erpc_free(result);
    }

    return err;
}

// Server shim for rpc_server_exec_write_confirm of rpc_gatt_server interface.
erpc_status_t rpc_gatt_server_service::rpc_server_exec_write_confirm_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t conn_id;
    uint16_t cause;
    uint16_t handle;
    bool result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&conn_id);

    codec->read(&cause);

    codec->read(&handle);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_server_exec_write_confirm(conn_id, cause, handle);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gatt_server_service_id, krpc_gatt_server_rpc_server_exec_write_confirm_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_server_attr_write_confirm of rpc_gatt_server interface.
erpc_status_t rpc_gatt_server_service::rpc_server_attr_write_confirm_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t conn_id;
    uint8_t service_id;
    uint16_t attrib_index;
    RPC_T_APP_RESULT cause;
    int32_t _tmp_local;
    bool result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&conn_id);

    codec->read(&service_id);

    codec->read(&attrib_index);

    codec->read(&_tmp_local);
    cause = static_cast<RPC_T_APP_RESULT>(_tmp_local);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_server_attr_write_confirm(conn_id, service_id, attrib_index, cause);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gatt_server_service_id, krpc_gatt_server_rpc_server_attr_write_confirm_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_server_attr_read_confirm of rpc_gatt_server interface.
erpc_status_t rpc_gatt_server_service::rpc_server_attr_read_confirm_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t conn_id;
    uint8_t service_id;
    uint16_t attrib_index;
    binary_t *data = NULL;
    data = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (data == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    RPC_T_APP_RESULT cause;
    int32_t _tmp_local;
    bool result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&conn_id);

    codec->read(&service_id);

    codec->read(&attrib_index);

    read_binary_t_struct(codec, data);

    codec->read(&_tmp_local);
    cause = static_cast<RPC_T_APP_RESULT>(_tmp_local);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_server_attr_read_confirm(conn_id, service_id, attrib_index, data, cause);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_gatt_server_service_id, krpc_gatt_server_rpc_server_attr_read_confirm_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (data)
    {
        free_binary_t_struct(data);
    }
    if (data)
    {
        erpc_free(data);
    }

    return err;
}

erpc_service_t create_rpc_ble_host_service()
{
    s_rpc_ble_host_service.construct();
    return s_rpc_ble_host_service.get();
}

void destroy_rpc_ble_host_service()
{
    s_rpc_ble_host_service.destroy();
}

erpc_service_t create_rpc_gap_service()
{
    s_rpc_gap_service.construct();
    return s_rpc_gap_service.get();
}

void destroy_rpc_gap_service()
{
    s_rpc_gap_service.destroy();
}

erpc_service_t create_rpc_gap_bone_service()
{
    s_rpc_gap_bone_service.construct();
    return s_rpc_gap_bone_service.get();
}

void destroy_rpc_gap_bone_service()
{
    s_rpc_gap_bone_service.destroy();
}

erpc_service_t create_rpc_gap_le_service()
{
    s_rpc_gap_le_service.construct();
    return s_rpc_gap_le_service.get();
}

void destroy_rpc_gap_le_service()
{
    s_rpc_gap_le_service.destroy();
}

erpc_service_t create_rpc_gap_config_service()
{
    s_rpc_gap_config_service.construct();
    return s_rpc_gap_config_service.get();
}

void destroy_rpc_gap_config_service()
{
    s_rpc_gap_config_service.destroy();
}

erpc_service_t create_rpc_gap_adv_service()
{
    s_rpc_gap_adv_service.construct();
    return s_rpc_gap_adv_service.get();
}

void destroy_rpc_gap_adv_service()
{
    s_rpc_gap_adv_service.destroy();
}

erpc_service_t create_rpc_gap_scan_service()
{
    s_rpc_gap_scan_service.construct();
    return s_rpc_gap_scan_service.get();
}

void destroy_rpc_gap_scan_service()
{
    s_rpc_gap_scan_service.destroy();
}

erpc_service_t create_rpc_gap_conn_service()
{
    s_rpc_gap_conn_service.construct();
    return s_rpc_gap_conn_service.get();
}

void destroy_rpc_gap_conn_service()
{
    s_rpc_gap_conn_service.destroy();
}

erpc_service_t create_rpc_gap_storage_service()
{
    s_rpc_gap_storage_service.construct();
    return s_rpc_gap_storage_service.get();
}

void destroy_rpc_gap_storage_service()
{
    s_rpc_gap_storage_service.destroy();
}

erpc_service_t create_rpc_gatt_client_service()
{
    s_rpc_gatt_client_service.construct();
    return s_rpc_gatt_client_service.get();
}

void destroy_rpc_gatt_client_service()
{
    s_rpc_gatt_client_service.destroy();
}

erpc_service_t create_rpc_gatt_server_service()
{
    s_rpc_gatt_server_service.construct();
    return s_rpc_gatt_server_service.get();
}

void destroy_rpc_gatt_server_service()
{
    s_rpc_gatt_server_service.destroy();
}
