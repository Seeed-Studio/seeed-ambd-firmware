/*
 * Generated by erpcgen 1.7.4 on Thu Oct 22 10:59:50 2020.
 *
 * AUTOGENERATED - DO NOT EDIT
 */


#include "erpc_client_manager.h"
#include "erpc_port.h"
#include "erpc_codec.h"
extern "C"
{
#include "rpc_ble_api.h"
// import callbacks declaration from other groups
#include "rpc_ble_callback.h"
#include "rpc_wifi_api.h"
#include "rpc_wifi_callback.h"
}

#if 10704 != ERPC_VERSION_NUMBER
#error "The generated shim code version is different to the rest of eRPC code."
#endif

using namespace erpc;
using namespace std;

extern ClientManager *g_client;

//! @brief Function to write struct binary_t
static void write_binary_t_struct(erpc::Codec * codec, const binary_t * data);

//! @brief Function to write struct RPC_T_GAP_LE_CONN_REQ_PARAM
static void write_RPC_T_GAP_LE_CONN_REQ_PARAM_struct(erpc::Codec * codec, const RPC_T_GAP_LE_CONN_REQ_PARAM * data);

//! @brief Function to write struct RPC_T_LOCAL_NAME
static void write_RPC_T_LOCAL_NAME_struct(erpc::Codec * codec, const RPC_T_LOCAL_NAME * data);

//! @brief Function to write struct RPC_T_LOCAL_APPEARANCE
static void write_RPC_T_LOCAL_APPEARANCE_struct(erpc::Codec * codec, const RPC_T_LOCAL_APPEARANCE * data);

//! @brief Function to write struct RPC_T_LE_REMOTE_BD
static void write_RPC_T_LE_REMOTE_BD_struct(erpc::Codec * codec, const RPC_T_LE_REMOTE_BD * data);

//! @brief Function to write struct RPC_T_LE_KEY_ENTRY
static void write_RPC_T_LE_KEY_ENTRY_struct(erpc::Codec * codec, const RPC_T_LE_KEY_ENTRY * data);

//! @brief Function to write struct RPC_T_LE_CCCD
static void write_RPC_T_LE_CCCD_struct(erpc::Codec * codec, const RPC_T_LE_CCCD * data);


// Write struct binary_t function implementation
static void write_binary_t_struct(erpc::Codec * codec, const binary_t * data)
{
    codec->writeBinary(data->dataLength, data->data);
}

// Write struct RPC_T_GAP_LE_CONN_REQ_PARAM function implementation
static void write_RPC_T_GAP_LE_CONN_REQ_PARAM_struct(erpc::Codec * codec, const RPC_T_GAP_LE_CONN_REQ_PARAM * data)
{
    codec->write(data->scan_interval);

    codec->write(data->scan_window);

    codec->write(data->conn_interval_min);

    codec->write(data->conn_interval_max);

    codec->write(data->conn_latency);

    codec->write(data->supv_tout);

    codec->write(data->ce_len_min);

    codec->write(data->ce_len_max);
}

// Write struct RPC_T_LOCAL_NAME function implementation
static void write_RPC_T_LOCAL_NAME_struct(erpc::Codec * codec, const RPC_T_LOCAL_NAME * data)
{
    for (uint32_t arrayCount0 = 0; arrayCount0 < 40; ++arrayCount0)
    {
        codec->write(data->local_name[arrayCount0]);
    }
}

// Write struct RPC_T_LOCAL_APPEARANCE function implementation
static void write_RPC_T_LOCAL_APPEARANCE_struct(erpc::Codec * codec, const RPC_T_LOCAL_APPEARANCE * data)
{
    codec->write(data->local_appearance);

    for (uint32_t arrayCount0 = 0; arrayCount0 < 2; ++arrayCount0)
    {
        codec->write(data->padding[arrayCount0]);
    }
}

// Write struct RPC_T_LE_REMOTE_BD function implementation
static void write_RPC_T_LE_REMOTE_BD_struct(erpc::Codec * codec, const RPC_T_LE_REMOTE_BD * data)
{
    for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
    {
        codec->write(data->addr[arrayCount0]);
    }

    codec->write(data->remote_bd_type);

    codec->write(data->bond_flags);
}

// Write struct RPC_T_LE_KEY_ENTRY function implementation
static void write_RPC_T_LE_KEY_ENTRY_struct(erpc::Codec * codec, const RPC_T_LE_KEY_ENTRY * data)
{
    codec->write(data->is_used);

    codec->write(data->idx);

    codec->write(data->flags);

    codec->write(data->local_bd_type);

    codec->write(data->app_data);

    for (uint32_t arrayCount0 = 0; arrayCount0 < 2; ++arrayCount0)
    {
        codec->write(data->reserved[arrayCount0]);
    }

    write_RPC_T_LE_REMOTE_BD_struct(codec, &(data->remote_bd));

    write_RPC_T_LE_REMOTE_BD_struct(codec, &(data->resolved_remote_bd));
}

// Write struct RPC_T_LE_CCCD function implementation
static void write_RPC_T_LE_CCCD_struct(erpc::Codec * codec, const RPC_T_LE_CCCD * data)
{
    codec->write(data->data_length);

    for (uint32_t arrayCount0 = 0; arrayCount0 < 3; ++arrayCount0)
    {
        codec->write(data->padding[arrayCount0]);
    }

    codec->write(data->data);
}


//! @brief Function to read struct binary_t
static void read_binary_t_struct(erpc::Codec * codec, binary_t * data);

//! @brief Function to read struct RPC_T_GAP_CONN_INFO
static void read_RPC_T_GAP_CONN_INFO_struct(erpc::Codec * codec, RPC_T_GAP_CONN_INFO * data);

//! @brief Function to read struct RPC_T_LOCAL_NAME
static void read_RPC_T_LOCAL_NAME_struct(erpc::Codec * codec, RPC_T_LOCAL_NAME * data);

//! @brief Function to read struct RPC_T_LOCAL_APPEARANCE
static void read_RPC_T_LOCAL_APPEARANCE_struct(erpc::Codec * codec, RPC_T_LOCAL_APPEARANCE * data);

//! @brief Function to read struct RPC_T_LE_REMOTE_BD
static void read_RPC_T_LE_REMOTE_BD_struct(erpc::Codec * codec, RPC_T_LE_REMOTE_BD * data);

//! @brief Function to read struct RPC_T_LE_KEY_ENTRY
static void read_RPC_T_LE_KEY_ENTRY_struct(erpc::Codec * codec, RPC_T_LE_KEY_ENTRY * data);

//! @brief Function to read struct RPC_T_LE_CCCD
static void read_RPC_T_LE_CCCD_struct(erpc::Codec * codec, RPC_T_LE_CCCD * data);


// Read struct binary_t function implementation
static void read_binary_t_struct(erpc::Codec * codec, binary_t * data)
{
    uint8_t * data_local;
    codec->readBinary(&data->dataLength, &data_local);
    data->data = (uint8_t *) erpc_malloc(data->dataLength * sizeof(uint8_t));
    if (data->data == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    else
    {
        memcpy(data->data, data_local, data->dataLength);
    }
}

// Read struct RPC_T_GAP_CONN_INFO function implementation
static void read_RPC_T_GAP_CONN_INFO_struct(erpc::Codec * codec, RPC_T_GAP_CONN_INFO * data)
{
    int32_t _tmp_local;
    codec->read(&_tmp_local);
    data->conn_state = static_cast<RPC_T_GAP_CONN_STATE>(_tmp_local);

    codec->read(&_tmp_local);
    data->role = static_cast<RPC_T_GAP_ROLE>(_tmp_local);

    for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
    {
        codec->read(&data->remote_bd[arrayCount0]);
    }

    codec->read(&data->remote_bd_type);
}

// Read struct RPC_T_LOCAL_NAME function implementation
static void read_RPC_T_LOCAL_NAME_struct(erpc::Codec * codec, RPC_T_LOCAL_NAME * data)
{
    for (uint32_t arrayCount0 = 0; arrayCount0 < 40; ++arrayCount0)
    {
        codec->read(&data->local_name[arrayCount0]);
    }
}

// Read struct RPC_T_LOCAL_APPEARANCE function implementation
static void read_RPC_T_LOCAL_APPEARANCE_struct(erpc::Codec * codec, RPC_T_LOCAL_APPEARANCE * data)
{
    codec->read(&data->local_appearance);

    for (uint32_t arrayCount0 = 0; arrayCount0 < 2; ++arrayCount0)
    {
        codec->read(&data->padding[arrayCount0]);
    }
}

// Read struct RPC_T_LE_REMOTE_BD function implementation
static void read_RPC_T_LE_REMOTE_BD_struct(erpc::Codec * codec, RPC_T_LE_REMOTE_BD * data)
{
    for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
    {
        codec->read(&data->addr[arrayCount0]);
    }

    codec->read(&data->remote_bd_type);

    codec->read(&data->bond_flags);
}

// Read struct RPC_T_LE_KEY_ENTRY function implementation
static void read_RPC_T_LE_KEY_ENTRY_struct(erpc::Codec * codec, RPC_T_LE_KEY_ENTRY * data)
{
    codec->read(&data->is_used);

    codec->read(&data->idx);

    codec->read(&data->flags);

    codec->read(&data->local_bd_type);

    codec->read(&data->app_data);

    for (uint32_t arrayCount0 = 0; arrayCount0 < 2; ++arrayCount0)
    {
        codec->read(&data->reserved[arrayCount0]);
    }

    read_RPC_T_LE_REMOTE_BD_struct(codec, &(data->remote_bd));

    read_RPC_T_LE_REMOTE_BD_struct(codec, &(data->resolved_remote_bd));
}

// Read struct RPC_T_LE_CCCD function implementation
static void read_RPC_T_LE_CCCD_struct(erpc::Codec * codec, RPC_T_LE_CCCD * data)
{
    codec->read(&data->data_length);

    for (uint32_t arrayCount0 = 0; arrayCount0 < 3; ++arrayCount0)
    {
        codec->read(&data->padding[arrayCount0]);
    }

    codec->read(&data->data);
}



// rpc_ble_host interface rpc_ble_init function client shim.
bool rpc_ble_init(void)
{
    erpc_status_t err = kErpcStatus_Success;

    bool result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_ble_host_service_id, krpc_ble_host_rpc_ble_init_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_ble_host_rpc_ble_init_id);

    if (err)
    {
        return false;
    }

    return result;
}

// rpc_ble_host interface rpc_ble_start function client shim.
void rpc_ble_start(void)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_ble_host_service_id, krpc_ble_host_rpc_ble_start_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_ble_host_rpc_ble_start_id);

    return;
}

// rpc_ble_host interface rpc_ble_deinit function client shim.
void rpc_ble_deinit(void)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_ble_host_service_id, krpc_ble_host_rpc_ble_deinit_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_ble_host_rpc_ble_deinit_id);

    return;
}

// rpc_gap interface rpc_gap_set_param function client shim.
RPC_T_GAP_CAUSE rpc_gap_set_param(RPC_T_GAP_PARAM_TYPE param, const binary_t * value)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_service_id, krpc_gap_rpc_gap_set_param_id, request.getSequence());

        codec->write(static_cast<int32_t>(param));

        write_binary_t_struct(codec, value);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_rpc_gap_set_param_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap interface rpc_gap_get_param function client shim.
RPC_T_GAP_CAUSE rpc_gap_get_param(RPC_T_GAP_PARAM_TYPE param, binary_t * value)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_service_id, krpc_gap_rpc_gap_get_param_id, request.getSequence());

        codec->write(static_cast<int32_t>(param));

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        read_binary_t_struct(codec, value);

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_rpc_gap_get_param_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap interface rpc_gap_set_pairable_mode function client shim.
RPC_T_GAP_CAUSE rpc_gap_set_pairable_mode(void)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_service_id, krpc_gap_rpc_gap_set_pairable_mode_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_rpc_gap_set_pairable_mode_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_bone interface rpc_le_bond_set_param function client shim.
RPC_T_GAP_CAUSE rpc_le_bond_set_param(RPC_T_LE_BOND_PARAM_TYPE param, const binary_t * value)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_bone_service_id, krpc_gap_bone_rpc_le_bond_set_param_id, request.getSequence());

        codec->write(static_cast<int32_t>(param));

        write_binary_t_struct(codec, value);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_bone_rpc_le_bond_set_param_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_bone interface rpc_le_bond_get_param function client shim.
RPC_T_GAP_CAUSE rpc_le_bond_get_param(RPC_T_LE_BOND_PARAM_TYPE param, binary_t * value)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_bone_service_id, krpc_gap_bone_rpc_le_bond_get_param_id, request.getSequence());

        codec->write(static_cast<int32_t>(param));

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        read_binary_t_struct(codec, value);

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_bone_rpc_le_bond_get_param_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_bone interface rpc_le_bond_pair function client shim.
RPC_T_GAP_CAUSE rpc_le_bond_pair(uint8_t conn_id)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_bone_service_id, krpc_gap_bone_rpc_le_bond_pair_id, request.getSequence());

        codec->write(conn_id);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_bone_rpc_le_bond_pair_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_bone interface rpc_le_bond_get_display_key function client shim.
RPC_T_GAP_CAUSE rpc_le_bond_get_display_key(uint8_t conn_id, uint32_t * key)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_bone_service_id, krpc_gap_bone_rpc_le_bond_get_display_key_id, request.getSequence());

        codec->write(conn_id);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(key);

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_bone_rpc_le_bond_get_display_key_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_bone interface rpc_le_bond_passkey_input_confirm function client shim.
RPC_T_GAP_CAUSE rpc_le_bond_passkey_input_confirm(uint8_t conn_id, uint32_t passcode, RPC_T_GAP_CFM_CAUSE cause)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_bone_service_id, krpc_gap_bone_rpc_le_bond_passkey_input_confirm_id, request.getSequence());

        codec->write(conn_id);

        codec->write(passcode);

        codec->write(static_cast<int32_t>(cause));

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_bone_rpc_le_bond_passkey_input_confirm_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_bone interface rpc_le_bond_oob_input_confirm function client shim.
RPC_T_GAP_CAUSE rpc_le_bond_oob_input_confirm(uint8_t conn_id, RPC_T_GAP_CFM_CAUSE cause)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_bone_service_id, krpc_gap_bone_rpc_le_bond_oob_input_confirm_id, request.getSequence());

        codec->write(conn_id);

        codec->write(static_cast<int32_t>(cause));

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_bone_rpc_le_bond_oob_input_confirm_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_bone interface rpc_le_bond_just_work_confirm function client shim.
RPC_T_GAP_CAUSE rpc_le_bond_just_work_confirm(uint8_t conn_id, RPC_T_GAP_CFM_CAUSE cause)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_bone_service_id, krpc_gap_bone_rpc_le_bond_just_work_confirm_id, request.getSequence());

        codec->write(conn_id);

        codec->write(static_cast<int32_t>(cause));

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_bone_rpc_le_bond_just_work_confirm_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_bone interface rpc_le_bond_passkey_display_confirm function client shim.
RPC_T_GAP_CAUSE rpc_le_bond_passkey_display_confirm(uint8_t conn_id, RPC_T_GAP_CFM_CAUSE cause)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_bone_service_id, krpc_gap_bone_rpc_le_bond_passkey_display_confirm_id, request.getSequence());

        codec->write(conn_id);

        codec->write(static_cast<int32_t>(cause));

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_bone_rpc_le_bond_passkey_display_confirm_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_bone interface rpc_le_bond_user_confirm function client shim.
RPC_T_GAP_CAUSE rpc_le_bond_user_confirm(uint8_t conn_id, RPC_T_GAP_CFM_CAUSE cause)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_bone_service_id, krpc_gap_bone_rpc_le_bond_user_confirm_id, request.getSequence());

        codec->write(conn_id);

        codec->write(static_cast<int32_t>(cause));

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_bone_rpc_le_bond_user_confirm_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_bone interface rpc_le_bond_cfg_local_key_distribute function client shim.
RPC_T_GAP_CAUSE rpc_le_bond_cfg_local_key_distribute(uint8_t init_dist, uint8_t rsp_dist)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_bone_service_id, krpc_gap_bone_rpc_le_bond_cfg_local_key_distribute_id, request.getSequence());

        codec->write(init_dist);

        codec->write(rsp_dist);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_bone_rpc_le_bond_cfg_local_key_distribute_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_bone interface rpc_le_bond_clear_all_keys function client shim.
void rpc_le_bond_clear_all_keys(void)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_bone_service_id, krpc_gap_bone_rpc_le_bond_clear_all_keys_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_bone_rpc_le_bond_clear_all_keys_id);

    return;
}

// rpc_gap_bone interface rpc_le_bond_delete_by_idx function client shim.
RPC_T_GAP_CAUSE rpc_le_bond_delete_by_idx(uint8_t idx)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_bone_service_id, krpc_gap_bone_rpc_le_bond_delete_by_idx_id, request.getSequence());

        codec->write(idx);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_bone_rpc_le_bond_delete_by_idx_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_bone interface rpc_le_bond_delete_by_bd function client shim.
RPC_T_GAP_CAUSE rpc_le_bond_delete_by_bd(const uint8_t bd_addr[6], RPC_T_GAP_REMOTE_ADDR_TYPE bd_type)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_bone_service_id, krpc_gap_bone_rpc_le_bond_delete_by_bd_id, request.getSequence());

        for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
        {
            codec->write(bd_addr[arrayCount0]);
        }

        codec->write(static_cast<int32_t>(bd_type));

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_bone_rpc_le_bond_delete_by_bd_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_bone interface rpc_le_bond_get_sec_level function client shim.
RPC_T_GAP_CAUSE rpc_le_bond_get_sec_level(uint8_t conn_id, RPC_T_GAP_SEC_LEVEL * sec_type)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_bone_service_id, krpc_gap_bone_rpc_le_bond_get_sec_level_id, request.getSequence());

        codec->write(conn_id);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        *sec_type = static_cast<RPC_T_GAP_SEC_LEVEL>(_tmp_local);

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_bone_rpc_le_bond_get_sec_level_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_le interface rpc_le_gap_init function client shim.
bool rpc_le_gap_init(uint8_t link_num)
{
    erpc_status_t err = kErpcStatus_Success;

    bool result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_le_service_id, krpc_gap_le_rpc_le_gap_init_id, request.getSequence());

        codec->write(link_num);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_le_rpc_le_gap_init_id);

    if (err)
    {
        return false;
    }

    return result;
}

// rpc_gap_le interface rpc_le_gap_msg_info_way function client shim.
void rpc_le_gap_msg_info_way(bool use_msg)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_le_service_id, krpc_gap_le_rpc_le_gap_msg_info_way_id, request.getSequence());

        codec->write(use_msg);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_le_rpc_le_gap_msg_info_way_id);

    return;
}

// rpc_gap_le interface rpc_le_get_max_link_num function client shim.
uint8_t rpc_le_get_max_link_num(void)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_le_service_id, krpc_gap_le_rpc_le_get_max_link_num_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_le_rpc_le_get_max_link_num_id);

    if (err)
    {
        return 0xFFU;
    }

    return result;
}

// rpc_gap_le interface rpc_le_set_gap_param function client shim.
RPC_T_GAP_CAUSE rpc_le_set_gap_param(RPC_T_GAP_LE_PARAM_TYPE param, const binary_t * value)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_le_service_id, krpc_gap_le_rpc_le_set_gap_param_id, request.getSequence());

        codec->write(static_cast<int32_t>(param));

        write_binary_t_struct(codec, value);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_le_rpc_le_set_gap_param_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_le interface rpc_le_get_gap_param function client shim.
RPC_T_GAP_CAUSE rpc_le_get_gap_param(RPC_T_GAP_LE_PARAM_TYPE param, binary_t * value)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_le_service_id, krpc_gap_le_rpc_le_get_gap_param_id, request.getSequence());

        codec->write(static_cast<int32_t>(param));

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        read_binary_t_struct(codec, value);

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_le_rpc_le_get_gap_param_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_le interface rpc_le_modify_white_list function client shim.
RPC_T_GAP_CAUSE rpc_le_modify_white_list(RPC_T_GAP_WHITE_LIST_OP operation, const uint8_t bd_addr[6], RPC_T_GAP_REMOTE_ADDR_TYPE bd_type)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_le_service_id, krpc_gap_le_rpc_le_modify_white_list_id, request.getSequence());

        codec->write(static_cast<int32_t>(operation));

        for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
        {
            codec->write(bd_addr[arrayCount0]);
        }

        codec->write(static_cast<int32_t>(bd_type));

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_le_rpc_le_modify_white_list_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_le interface rpc_le_gen_rand_addr function client shim.
RPC_T_GAP_CAUSE rpc_le_gen_rand_addr(RPC_T_GAP_RAND_ADDR_TYPE rand_addr_type, uint8_t random_bd[6])
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_le_service_id, krpc_gap_le_rpc_le_gen_rand_addr_id, request.getSequence());

        codec->write(static_cast<int32_t>(rand_addr_type));

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
        {
            codec->read(&random_bd[arrayCount0]);
        }

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_le_rpc_le_gen_rand_addr_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_le interface rpc_le_set_rand_addr function client shim.
RPC_T_GAP_CAUSE rpc_le_set_rand_addr(const uint8_t random_bd[6])
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_le_service_id, krpc_gap_le_rpc_le_set_rand_addr_id, request.getSequence());

        for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
        {
            codec->write(random_bd[arrayCount0]);
        }

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_le_rpc_le_set_rand_addr_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_le interface rpc_le_cfg_local_identity_address function client shim.
RPC_T_GAP_CAUSE rpc_le_cfg_local_identity_address(const uint8_t addr[6], RPC_T_GAP_IDENT_ADDR_TYPE ident_addr_type)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_le_service_id, krpc_gap_le_rpc_le_cfg_local_identity_address_id, request.getSequence());

        for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
        {
            codec->write(addr[arrayCount0]);
        }

        codec->write(static_cast<int32_t>(ident_addr_type));

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_le_rpc_le_cfg_local_identity_address_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_le interface rpc_le_set_host_chann_classif function client shim.
RPC_T_GAP_CAUSE rpc_le_set_host_chann_classif(uint8_t p_channel_map)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_le_service_id, krpc_gap_le_rpc_le_set_host_chann_classif_id, request.getSequence());

        codec->write(p_channel_map);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_le_rpc_le_set_host_chann_classif_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_le interface rpc_le_write_default_data_len function client shim.
RPC_T_GAP_CAUSE rpc_le_write_default_data_len(uint16_t tx_octets, uint16_t tx_time)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_le_service_id, krpc_gap_le_rpc_le_write_default_data_len_id, request.getSequence());

        codec->write(tx_octets);

        codec->write(tx_time);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_le_rpc_le_write_default_data_len_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_config interface rpc_gap_config_cccd_not_check function client shim.
void rpc_gap_config_cccd_not_check(RPC_T_GAP_CONFIG_GATT_CCCD_NOT_CHECK cccd_not_check_flag)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_config_service_id, krpc_gap_config_rpc_gap_config_cccd_not_check_id, request.getSequence());

        codec->write(static_cast<int32_t>(cccd_not_check_flag));

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_config_rpc_gap_config_cccd_not_check_id);

    return;
}

// rpc_gap_config interface rpc_gap_config_ccc_bits_count function client shim.
void rpc_gap_config_ccc_bits_count(uint8_t gatt_server_ccc_bits_count, uint8_t gatt_storage_ccc_bits_count)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_config_service_id, krpc_gap_config_rpc_gap_config_ccc_bits_count_id, request.getSequence());

        codec->write(gatt_server_ccc_bits_count);

        codec->write(gatt_storage_ccc_bits_count);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_config_rpc_gap_config_ccc_bits_count_id);

    return;
}

// rpc_gap_config interface rpc_gap_config_max_attribute_table_count function client shim.
void rpc_gap_config_max_attribute_table_count(uint8_t gatt_max_attribute_table_count)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_config_service_id, krpc_gap_config_rpc_gap_config_max_attribute_table_count_id, request.getSequence());

        codec->write(gatt_max_attribute_table_count);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_config_rpc_gap_config_max_attribute_table_count_id);

    return;
}

// rpc_gap_config interface rpc_gap_config_max_mtu_size function client shim.
void rpc_gap_config_max_mtu_size(uint16_t att_max_mtu_size)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_config_service_id, krpc_gap_config_rpc_gap_config_max_mtu_size_id, request.getSequence());

        codec->write(att_max_mtu_size);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_config_rpc_gap_config_max_mtu_size_id);

    return;
}

// rpc_gap_config interface rpc_gap_config_bte_pool_size function client shim.
void rpc_gap_config_bte_pool_size(uint8_t bte_pool_size)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_config_service_id, krpc_gap_config_rpc_gap_config_bte_pool_size_id, request.getSequence());

        codec->write(bte_pool_size);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_config_rpc_gap_config_bte_pool_size_id);

    return;
}

// rpc_gap_config interface rpc_gap_config_bt_report_buf_num function client shim.
void rpc_gap_config_bt_report_buf_num(uint8_t bt_report_buf_num)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_config_service_id, krpc_gap_config_rpc_gap_config_bt_report_buf_num_id, request.getSequence());

        codec->write(bt_report_buf_num);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_config_rpc_gap_config_bt_report_buf_num_id);

    return;
}

// rpc_gap_config interface rpc_gap_config_le_key_storage_flag function client shim.
void rpc_gap_config_le_key_storage_flag(uint16_t le_key_storage_flag)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_config_service_id, krpc_gap_config_rpc_gap_config_le_key_storage_flag_id, request.getSequence());

        codec->write(le_key_storage_flag);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_config_rpc_gap_config_le_key_storage_flag_id);

    return;
}

// rpc_gap_config interface rpc_gap_config_max_le_paired_device function client shim.
void rpc_gap_config_max_le_paired_device(uint8_t max_le_paired_device)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_config_service_id, krpc_gap_config_rpc_gap_config_max_le_paired_device_id, request.getSequence());

        codec->write(max_le_paired_device);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_config_rpc_gap_config_max_le_paired_device_id);

    return;
}

// rpc_gap_config interface rpc_gap_config_max_le_link_num function client shim.
void rpc_gap_config_max_le_link_num(uint8_t le_link_num)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_config_service_id, krpc_gap_config_rpc_gap_config_max_le_link_num_id, request.getSequence());

        codec->write(le_link_num);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_config_rpc_gap_config_max_le_link_num_id);

    return;
}

// rpc_gap_adv interface rpc_le_adv_set_param function client shim.
RPC_T_GAP_CAUSE rpc_le_adv_set_param(RPC_T_LE_ADV_PARAM_TYPE param, const binary_t * value)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_adv_service_id, krpc_gap_adv_rpc_le_adv_set_param_id, request.getSequence());

        codec->write(static_cast<int32_t>(param));

        write_binary_t_struct(codec, value);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_adv_rpc_le_adv_set_param_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_adv interface rpc_le_adv_get_param function client shim.
RPC_T_GAP_CAUSE rpc_le_adv_get_param(RPC_T_LE_ADV_PARAM_TYPE param, binary_t * value)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_adv_service_id, krpc_gap_adv_rpc_le_adv_get_param_id, request.getSequence());

        codec->write(static_cast<int32_t>(param));

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        read_binary_t_struct(codec, value);

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_adv_rpc_le_adv_get_param_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_adv interface rpc_le_adv_start function client shim.
RPC_T_GAP_CAUSE rpc_le_adv_start(void)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_adv_service_id, krpc_gap_adv_rpc_le_adv_start_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_adv_rpc_le_adv_start_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_adv interface rpc_le_adv_stop function client shim.
RPC_T_GAP_CAUSE rpc_le_adv_stop(void)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_adv_service_id, krpc_gap_adv_rpc_le_adv_stop_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_adv_rpc_le_adv_stop_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_adv interface rpc_le_adv_update_param function client shim.
RPC_T_GAP_CAUSE rpc_le_adv_update_param(void)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_adv_service_id, krpc_gap_adv_rpc_le_adv_update_param_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_adv_rpc_le_adv_update_param_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_scan interface rpc_le_scan_set_param function client shim.
RPC_T_GAP_CAUSE rpc_le_scan_set_param(RPC_T_LE_SCAN_PARAM_TYPE param, const binary_t * value)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_scan_service_id, krpc_gap_scan_rpc_le_scan_set_param_id, request.getSequence());

        codec->write(static_cast<int32_t>(param));

        write_binary_t_struct(codec, value);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_scan_rpc_le_scan_set_param_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_scan interface rpc_le_scan_get_param function client shim.
RPC_T_GAP_CAUSE rpc_le_scan_get_param(RPC_T_LE_SCAN_PARAM_TYPE param, binary_t * value)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_scan_service_id, krpc_gap_scan_rpc_le_scan_get_param_id, request.getSequence());

        codec->write(static_cast<int32_t>(param));

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        read_binary_t_struct(codec, value);

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_scan_rpc_le_scan_get_param_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_scan interface rpc_le_scan_start function client shim.
RPC_T_GAP_CAUSE rpc_le_scan_start(void)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_scan_service_id, krpc_gap_scan_rpc_le_scan_start_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_scan_rpc_le_scan_start_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_scan interface rpc_le_scan_timer_start function client shim.
RPC_T_GAP_CAUSE rpc_le_scan_timer_start(uint32_t tick)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_scan_service_id, krpc_gap_scan_rpc_le_scan_timer_start_id, request.getSequence());

        codec->write(tick);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_scan_rpc_le_scan_timer_start_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_scan interface rpc_le_scan_stop function client shim.
RPC_T_GAP_CAUSE rpc_le_scan_stop(void)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_scan_service_id, krpc_gap_scan_rpc_le_scan_stop_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_scan_rpc_le_scan_stop_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_scan interface rpc_le_scan_info_filter function client shim.
bool rpc_le_scan_info_filter(bool enable, uint8_t offset, uint8_t len, const uint8_t p_filter[31])
{
    erpc_status_t err = kErpcStatus_Success;

    bool result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_scan_service_id, krpc_gap_scan_rpc_le_scan_info_filter_id, request.getSequence());

        codec->write(enable);

        codec->write(offset);

        codec->write(len);

        for (uint32_t arrayCount0 = 0; arrayCount0 < 31; ++arrayCount0)
        {
            codec->write(p_filter[arrayCount0]);
        }

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_scan_rpc_le_scan_info_filter_id);

    if (err)
    {
        return false;
    }

    return result;
}

// rpc_gap_conn interface rpc_le_get_conn_param function client shim.
RPC_T_GAP_CAUSE rpc_le_get_conn_param(RPC_T_LE_CONN_PARAM_TYPE param, binary_t * value, uint8_t conn_id)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_conn_service_id, krpc_gap_conn_rpc_le_get_conn_param_id, request.getSequence());

        codec->write(static_cast<int32_t>(param));

        codec->write(conn_id);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        read_binary_t_struct(codec, value);

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_conn_rpc_le_get_conn_param_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_conn interface rpc_le_get_conn_info function client shim.
bool rpc_le_get_conn_info(uint8_t conn_id, RPC_T_GAP_CONN_INFO * p_conn_info)
{
    erpc_status_t err = kErpcStatus_Success;

    bool result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_conn_service_id, krpc_gap_conn_rpc_le_get_conn_info_id, request.getSequence());

        codec->write(conn_id);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        read_RPC_T_GAP_CONN_INFO_struct(codec, p_conn_info);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_conn_rpc_le_get_conn_info_id);

    if (err)
    {
        return false;
    }

    return result;
}

// rpc_gap_conn interface rpc_le_get_conn_addr function client shim.
bool rpc_le_get_conn_addr(uint8_t conn_id, uint8_t bd_addr[6], uint8_t * bd_type)
{
    erpc_status_t err = kErpcStatus_Success;

    bool result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_conn_service_id, krpc_gap_conn_rpc_le_get_conn_addr_id, request.getSequence());

        codec->write(conn_id);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
        {
            codec->read(&bd_addr[arrayCount0]);
        }

        codec->read(bd_type);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_conn_rpc_le_get_conn_addr_id);

    if (err)
    {
        return false;
    }

    return result;
}

// rpc_gap_conn interface rpc_le_get_conn_id function client shim.
bool rpc_le_get_conn_id(const uint8_t bd_addr[6], uint8_t bd_type, uint8_t * p_conn_id)
{
    erpc_status_t err = kErpcStatus_Success;

    bool result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_conn_service_id, krpc_gap_conn_rpc_le_get_conn_id_id, request.getSequence());

        for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
        {
            codec->write(bd_addr[arrayCount0]);
        }

        codec->write(bd_type);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(p_conn_id);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_conn_rpc_le_get_conn_id_id);

    if (err)
    {
        return false;
    }

    return result;
}

// rpc_gap_conn interface rpc_le_get_active_link_num function client shim.
uint8_t rpc_le_get_active_link_num(void)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_conn_service_id, krpc_gap_conn_rpc_le_get_active_link_num_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_conn_rpc_le_get_active_link_num_id);

    if (err)
    {
        return 0xFFU;
    }

    return result;
}

// rpc_gap_conn interface rpc_le_get_idle_link_num function client shim.
uint8_t rpc_le_get_idle_link_num(void)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_conn_service_id, krpc_gap_conn_rpc_le_get_idle_link_num_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_conn_rpc_le_get_idle_link_num_id);

    if (err)
    {
        return 0xFFU;
    }

    return result;
}

// rpc_gap_conn interface rpc_le_disconnect function client shim.
RPC_T_GAP_CAUSE rpc_le_disconnect(uint8_t conn_id)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_conn_service_id, krpc_gap_conn_rpc_le_disconnect_id, request.getSequence());

        codec->write(conn_id);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_conn_rpc_le_disconnect_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_conn interface rpc_le_read_rssi function client shim.
RPC_T_GAP_CAUSE rpc_le_read_rssi(uint8_t conn_id)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_conn_service_id, krpc_gap_conn_rpc_le_read_rssi_id, request.getSequence());

        codec->write(conn_id);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_conn_rpc_le_read_rssi_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_conn interface rpc_le_set_data_len function client shim.
RPC_T_GAP_CAUSE rpc_le_set_data_len(uint8_t conn_id, uint16_t tx_octets, uint16_t tx_time)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_conn_service_id, krpc_gap_conn_rpc_le_set_data_len_id, request.getSequence());

        codec->write(conn_id);

        codec->write(tx_octets);

        codec->write(tx_time);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_conn_rpc_le_set_data_len_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_conn interface rpc_le_set_phy function client shim.
RPC_T_GAP_CAUSE rpc_le_set_phy(uint8_t conn_id, uint8_t all_phys, uint8_t tx_phys, uint8_t rx_phys, RPC_T_GAP_PHYS_OPTIONS phy_options)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_conn_service_id, krpc_gap_conn_rpc_le_set_phy_id, request.getSequence());

        codec->write(conn_id);

        codec->write(all_phys);

        codec->write(tx_phys);

        codec->write(rx_phys);

        codec->write(static_cast<int32_t>(phy_options));

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_conn_rpc_le_set_phy_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_conn interface rpc_le_set_conn_param function client shim.
RPC_T_GAP_CAUSE rpc_le_set_conn_param(RPC_T_GAP_CONN_PARAM_TYPE conn_type, const RPC_T_GAP_LE_CONN_REQ_PARAM * p_conn_param)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_conn_service_id, krpc_gap_conn_rpc_le_set_conn_param_id, request.getSequence());

        codec->write(static_cast<int32_t>(conn_type));

        write_RPC_T_GAP_LE_CONN_REQ_PARAM_struct(codec, p_conn_param);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_conn_rpc_le_set_conn_param_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_conn interface rpc_le_connect function client shim.
RPC_T_GAP_CAUSE rpc_le_connect(uint8_t init_phys, const uint8_t remote_bd[6], RPC_T_GAP_REMOTE_ADDR_TYPE remote_bd_type, RPC_T_GAP_LOCAL_ADDR_TYPE local_bd_type, uint16_t scan_timeout)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_conn_service_id, krpc_gap_conn_rpc_le_connect_id, request.getSequence());

        codec->write(init_phys);

        for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
        {
            codec->write(remote_bd[arrayCount0]);
        }

        codec->write(static_cast<int32_t>(remote_bd_type));

        codec->write(static_cast<int32_t>(local_bd_type));

        codec->write(scan_timeout);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_conn_rpc_le_connect_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_conn interface rpc_le_update_conn_param function client shim.
RPC_T_GAP_CAUSE rpc_le_update_conn_param(uint8_t conn_id, uint16_t conn_interval_min, uint16_t conn_interval_max, uint16_t conn_latency, uint16_t supervision_timeout, uint16_t ce_length_min, uint16_t ce_length_max)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_conn_service_id, krpc_gap_conn_rpc_le_update_conn_param_id, request.getSequence());

        codec->write(conn_id);

        codec->write(conn_interval_min);

        codec->write(conn_interval_max);

        codec->write(conn_latency);

        codec->write(supervision_timeout);

        codec->write(ce_length_min);

        codec->write(ce_length_max);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_conn_rpc_le_update_conn_param_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_storage interface rpc_flash_save_local_name function client shim.
uint32_t rpc_flash_save_local_name(const RPC_T_LOCAL_NAME * p_data)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_storage_service_id, krpc_gap_storage_rpc_flash_save_local_name_id, request.getSequence());

        write_RPC_T_LOCAL_NAME_struct(codec, p_data);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_storage_rpc_flash_save_local_name_id);

    if (err)
    {
        return 0xFFFFFFFFU;
    }

    return result;
}

// rpc_gap_storage interface rpc_flash_load_local_name function client shim.
uint32_t rpc_flash_load_local_name(RPC_T_LOCAL_NAME * p_data)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_storage_service_id, krpc_gap_storage_rpc_flash_load_local_name_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        read_RPC_T_LOCAL_NAME_struct(codec, p_data);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_storage_rpc_flash_load_local_name_id);

    if (err)
    {
        return 0xFFFFFFFFU;
    }

    return result;
}

// rpc_gap_storage interface rpc_flash_save_local_appearance function client shim.
uint32_t rpc_flash_save_local_appearance(const RPC_T_LOCAL_APPEARANCE * p_data)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_storage_service_id, krpc_gap_storage_rpc_flash_save_local_appearance_id, request.getSequence());

        write_RPC_T_LOCAL_APPEARANCE_struct(codec, p_data);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_storage_rpc_flash_save_local_appearance_id);

    if (err)
    {
        return 0xFFFFFFFFU;
    }

    return result;
}

// rpc_gap_storage interface rpc_flash_load_local_appearance function client shim.
uint32_t rpc_flash_load_local_appearance(RPC_T_LOCAL_APPEARANCE * p_data)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_storage_service_id, krpc_gap_storage_rpc_flash_load_local_appearance_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        read_RPC_T_LOCAL_APPEARANCE_struct(codec, p_data);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_storage_rpc_flash_load_local_appearance_id);

    if (err)
    {
        return 0xFFFFFFFFU;
    }

    return result;
}

// rpc_gap_storage interface rpc_le_find_key_entry function client shim.
RPC_T_LE_KEY_ENTRY * rpc_le_find_key_entry(const uint8_t bd_addr[6], RPC_T_GAP_REMOTE_ADDR_TYPE bd_type)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_LE_KEY_ENTRY * result = NULL;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_storage_service_id, krpc_gap_storage_rpc_le_find_key_entry_id, request.getSequence());

        for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
        {
            codec->write(bd_addr[arrayCount0]);
        }

        codec->write(static_cast<int32_t>(bd_type));

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        bool isNull;
        codec->readNullFlag(&isNull);
        if (!isNull)
        {
            result = (RPC_T_LE_KEY_ENTRY *) erpc_malloc(sizeof(RPC_T_LE_KEY_ENTRY));
            if (result == NULL)
            {
                codec->updateStatus(kErpcStatus_MemoryError);
            }
            read_RPC_T_LE_KEY_ENTRY_struct(codec, result);
        }
        else
        {
            result = NULL;
        }

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_storage_rpc_le_find_key_entry_id);

    return result;
}

// rpc_gap_storage interface rpc_le_find_key_entry_by_idx function client shim.
RPC_T_LE_KEY_ENTRY * rpc_le_find_key_entry_by_idx(uint8_t idx)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_LE_KEY_ENTRY * result = NULL;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_storage_service_id, krpc_gap_storage_rpc_le_find_key_entry_by_idx_id, request.getSequence());

        codec->write(idx);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        bool isNull;
        codec->readNullFlag(&isNull);
        if (!isNull)
        {
            result = (RPC_T_LE_KEY_ENTRY *) erpc_malloc(sizeof(RPC_T_LE_KEY_ENTRY));
            if (result == NULL)
            {
                codec->updateStatus(kErpcStatus_MemoryError);
            }
            read_RPC_T_LE_KEY_ENTRY_struct(codec, result);
        }
        else
        {
            result = NULL;
        }

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_storage_rpc_le_find_key_entry_by_idx_id);

    return result;
}

// rpc_gap_storage interface rpc_le_get_bond_dev_num function client shim.
uint8_t rpc_le_get_bond_dev_num(void)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_storage_service_id, krpc_gap_storage_rpc_le_get_bond_dev_num_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_storage_rpc_le_get_bond_dev_num_id);

    if (err)
    {
        return 0xFFU;
    }

    return result;
}

// rpc_gap_storage interface rpc_le_get_low_priority_bond function client shim.
RPC_T_LE_KEY_ENTRY * rpc_le_get_low_priority_bond(void)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_LE_KEY_ENTRY * result = NULL;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_storage_service_id, krpc_gap_storage_rpc_le_get_low_priority_bond_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        bool isNull;
        codec->readNullFlag(&isNull);
        if (!isNull)
        {
            result = (RPC_T_LE_KEY_ENTRY *) erpc_malloc(sizeof(RPC_T_LE_KEY_ENTRY));
            if (result == NULL)
            {
                codec->updateStatus(kErpcStatus_MemoryError);
            }
            read_RPC_T_LE_KEY_ENTRY_struct(codec, result);
        }
        else
        {
            result = NULL;
        }

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_storage_rpc_le_get_low_priority_bond_id);

    return result;
}

// rpc_gap_storage interface rpc_le_get_high_priority_bond function client shim.
RPC_T_LE_KEY_ENTRY * rpc_le_get_high_priority_bond(void)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_LE_KEY_ENTRY * result = NULL;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_storage_service_id, krpc_gap_storage_rpc_le_get_high_priority_bond_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        bool isNull;
        codec->readNullFlag(&isNull);
        if (!isNull)
        {
            result = (RPC_T_LE_KEY_ENTRY *) erpc_malloc(sizeof(RPC_T_LE_KEY_ENTRY));
            if (result == NULL)
            {
                codec->updateStatus(kErpcStatus_MemoryError);
            }
            read_RPC_T_LE_KEY_ENTRY_struct(codec, result);
        }
        else
        {
            result = NULL;
        }

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_storage_rpc_le_get_high_priority_bond_id);

    return result;
}

// rpc_gap_storage interface rpc_le_set_high_priority_bond function client shim.
bool rpc_le_set_high_priority_bond(const uint8_t bd_addr[6], RPC_T_GAP_REMOTE_ADDR_TYPE bd_type)
{
    erpc_status_t err = kErpcStatus_Success;

    bool result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_storage_service_id, krpc_gap_storage_rpc_le_set_high_priority_bond_id, request.getSequence());

        for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
        {
            codec->write(bd_addr[arrayCount0]);
        }

        codec->write(static_cast<int32_t>(bd_type));

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_storage_rpc_le_set_high_priority_bond_id);

    if (err)
    {
        return false;
    }

    return result;
}

// rpc_gap_storage interface rpc_le_resolve_random_address function client shim.
bool rpc_le_resolve_random_address(const uint8_t unresolved_addr[6], uint8_t resolved_addr[6], RPC_T_GAP_IDENT_ADDR_TYPE * resolved_addr_type)
{
    erpc_status_t err = kErpcStatus_Success;

    bool result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_storage_service_id, krpc_gap_storage_rpc_le_resolve_random_address_id, request.getSequence());

        for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
        {
            codec->write(unresolved_addr[arrayCount0]);
        }

        for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
        {
            codec->write(resolved_addr[arrayCount0]);
        }

        codec->write(static_cast<int32_t>(*resolved_addr_type));

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
        {
            codec->read(&resolved_addr[arrayCount0]);
        }

        codec->read(&_tmp_local);
        *resolved_addr_type = static_cast<RPC_T_GAP_IDENT_ADDR_TYPE>(_tmp_local);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_storage_rpc_le_resolve_random_address_id);

    if (err)
    {
        return false;
    }

    return result;
}

// rpc_gap_storage interface rpc_le_get_cccd_data function client shim.
bool rpc_le_get_cccd_data(const RPC_T_LE_KEY_ENTRY * p_entry, RPC_T_LE_CCCD * p_data)
{
    erpc_status_t err = kErpcStatus_Success;

    bool result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_storage_service_id, krpc_gap_storage_rpc_le_get_cccd_data_id, request.getSequence());

        write_RPC_T_LE_KEY_ENTRY_struct(codec, p_entry);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        read_RPC_T_LE_CCCD_struct(codec, p_data);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_storage_rpc_le_get_cccd_data_id);

    if (err)
    {
        return false;
    }

    return result;
}

// rpc_gap_storage interface rpc_le_gen_bond_dev function client shim.
bool rpc_le_gen_bond_dev(const uint8_t bd_addr[6], RPC_T_GAP_REMOTE_ADDR_TYPE bd_type, RPC_T_GAP_LOCAL_ADDR_TYPE local_bd_type, const binary_t * local_ltk, RPC_T_LE_KEY_TYPE key_type, const RPC_T_LE_CCCD * p_cccd)
{
    erpc_status_t err = kErpcStatus_Success;

    bool result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_storage_service_id, krpc_gap_storage_rpc_le_gen_bond_dev_id, request.getSequence());

        for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
        {
            codec->write(bd_addr[arrayCount0]);
        }

        codec->write(static_cast<int32_t>(bd_type));

        codec->write(static_cast<int32_t>(local_bd_type));

        write_binary_t_struct(codec, local_ltk);

        codec->write(static_cast<int32_t>(key_type));

        write_RPC_T_LE_CCCD_struct(codec, p_cccd);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_storage_rpc_le_gen_bond_dev_id);

    if (err)
    {
        return false;
    }

    return result;
}

// rpc_gap_storage interface rpc_le_get_dev_bond_info_len function client shim.
uint16_t rpc_le_get_dev_bond_info_len(void)
{
    erpc_status_t err = kErpcStatus_Success;

    uint16_t result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_storage_service_id, krpc_gap_storage_rpc_le_get_dev_bond_info_len_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_storage_rpc_le_get_dev_bond_info_len_id);

    if (err)
    {
        return 0xFFFFU;
    }

    return result;
}

// rpc_gap_storage interface rpc_le_set_dev_bond_info function client shim.
RPC_T_LE_KEY_ENTRY * rpc_le_set_dev_bond_info(const binary_t * p_data, bool * exist)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_LE_KEY_ENTRY * result = NULL;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_storage_service_id, krpc_gap_storage_rpc_le_set_dev_bond_info_id, request.getSequence());

        write_binary_t_struct(codec, p_data);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(exist);

        bool isNull;
        codec->readNullFlag(&isNull);
        if (!isNull)
        {
            result = (RPC_T_LE_KEY_ENTRY *) erpc_malloc(sizeof(RPC_T_LE_KEY_ENTRY));
            if (result == NULL)
            {
                codec->updateStatus(kErpcStatus_MemoryError);
            }
            read_RPC_T_LE_KEY_ENTRY_struct(codec, result);
        }
        else
        {
            result = NULL;
        }

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_storage_rpc_le_set_dev_bond_info_id);

    return result;
}

// rpc_gap_storage interface rpc_le_get_dev_bond_info function client shim.
bool rpc_le_get_dev_bond_info(const RPC_T_LE_KEY_ENTRY * p_entry, binary_t * p_data)
{
    erpc_status_t err = kErpcStatus_Success;

    bool result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_storage_service_id, krpc_gap_storage_rpc_le_get_dev_bond_info_id, request.getSequence());

        write_RPC_T_LE_KEY_ENTRY_struct(codec, p_entry);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        read_binary_t_struct(codec, p_data);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_storage_rpc_le_get_dev_bond_info_id);

    if (err)
    {
        return false;
    }

    return result;
}

// rpc_gatt_client interface rpc_ble_client_init function client shim.
bool rpc_ble_client_init(uint8_t num)
{
    erpc_status_t err = kErpcStatus_Success;

    bool result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gatt_client_service_id, krpc_gatt_client_rpc_ble_client_init_id, request.getSequence());

        codec->write(num);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gatt_client_rpc_ble_client_init_id);

    if (err)
    {
        return false;
    }

    return result;
}

// rpc_gatt_client interface rpc_ble_add_client function client shim.
uint8_t rpc_ble_add_client(uint8_t app_id, uint8_t link_num)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gatt_client_service_id, krpc_gatt_client_rpc_ble_add_client_id, request.getSequence());

        codec->write(app_id);

        codec->write(link_num);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gatt_client_rpc_ble_add_client_id);

    if (err)
    {
        return 0xFFU;
    }

    return result;
}

// rpc_gatt_client interface rpc_client_init function client shim.
void rpc_client_init(uint8_t client_num)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gatt_client_service_id, krpc_gatt_client_rpc_client_init_id, request.getSequence());

        codec->write(client_num);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gatt_client_rpc_client_init_id);

    return;
}

// rpc_gatt_client interface rpc_client_all_primary_srv_discovery function client shim.
RPC_T_GAP_CAUSE rpc_client_all_primary_srv_discovery(uint8_t conn_id, uint8_t client_id)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gatt_client_service_id, krpc_gatt_client_rpc_client_all_primary_srv_discovery_id, request.getSequence());

        codec->write(conn_id);

        codec->write(client_id);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gatt_client_rpc_client_all_primary_srv_discovery_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gatt_client interface rpc_client_by_uuid_srv_discovery function client shim.
RPC_T_GAP_CAUSE rpc_client_by_uuid_srv_discovery(uint8_t conn_id, uint8_t client_id, uint16_t uuid16)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gatt_client_service_id, krpc_gatt_client_rpc_client_by_uuid_srv_discovery_id, request.getSequence());

        codec->write(conn_id);

        codec->write(client_id);

        codec->write(uuid16);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gatt_client_rpc_client_by_uuid_srv_discovery_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gatt_client interface rpc_client_by_uuid128_srv_discovery function client shim.
RPC_T_GAP_CAUSE rpc_client_by_uuid128_srv_discovery(uint8_t conn_id, uint8_t client_id, const uint8_t p_uuid128[16])
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gatt_client_service_id, krpc_gatt_client_rpc_client_by_uuid128_srv_discovery_id, request.getSequence());

        codec->write(conn_id);

        codec->write(client_id);

        for (uint32_t arrayCount0 = 0; arrayCount0 < 16; ++arrayCount0)
        {
            codec->write(p_uuid128[arrayCount0]);
        }

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gatt_client_rpc_client_by_uuid128_srv_discovery_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gatt_client interface rpc_client_relationship_discovery function client shim.
RPC_T_GAP_CAUSE rpc_client_relationship_discovery(uint8_t conn_id, uint8_t client_id, uint16_t start_handle, uint16_t end_handle)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gatt_client_service_id, krpc_gatt_client_rpc_client_relationship_discovery_id, request.getSequence());

        codec->write(conn_id);

        codec->write(client_id);

        codec->write(start_handle);

        codec->write(end_handle);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gatt_client_rpc_client_relationship_discovery_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gatt_client interface rpc_client_all_char_discovery function client shim.
RPC_T_GAP_CAUSE rpc_client_all_char_discovery(uint8_t conn_id, uint8_t client_id, uint16_t start_handle, uint16_t end_handle)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gatt_client_service_id, krpc_gatt_client_rpc_client_all_char_discovery_id, request.getSequence());

        codec->write(conn_id);

        codec->write(client_id);

        codec->write(start_handle);

        codec->write(end_handle);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gatt_client_rpc_client_all_char_discovery_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gatt_client interface rpc_client_by_uuid_char_discovery function client shim.
RPC_T_GAP_CAUSE rpc_client_by_uuid_char_discovery(uint8_t conn_id, uint8_t client_id, uint16_t start_handle, uint16_t end_handle, uint16_t uuid16)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gatt_client_service_id, krpc_gatt_client_rpc_client_by_uuid_char_discovery_id, request.getSequence());

        codec->write(conn_id);

        codec->write(client_id);

        codec->write(start_handle);

        codec->write(end_handle);

        codec->write(uuid16);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gatt_client_rpc_client_by_uuid_char_discovery_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gatt_client interface rpc_client_by_uuid128_char_discovery function client shim.
RPC_T_GAP_CAUSE rpc_client_by_uuid128_char_discovery(uint8_t conn_id, uint8_t client_id, uint16_t start_handle, uint16_t end_handle, const uint8_t p_uuid128[16])
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gatt_client_service_id, krpc_gatt_client_rpc_client_by_uuid128_char_discovery_id, request.getSequence());

        codec->write(conn_id);

        codec->write(client_id);

        codec->write(start_handle);

        codec->write(end_handle);

        for (uint32_t arrayCount0 = 0; arrayCount0 < 16; ++arrayCount0)
        {
            codec->write(p_uuid128[arrayCount0]);
        }

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gatt_client_rpc_client_by_uuid128_char_discovery_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gatt_client interface rpc_client_all_char_descriptor_discovery function client shim.
RPC_T_GAP_CAUSE rpc_client_all_char_descriptor_discovery(uint8_t conn_id, uint8_t client_id, uint16_t start_handle, uint16_t end_handle)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gatt_client_service_id, krpc_gatt_client_rpc_client_all_char_descriptor_discovery_id, request.getSequence());

        codec->write(conn_id);

        codec->write(client_id);

        codec->write(start_handle);

        codec->write(end_handle);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gatt_client_rpc_client_all_char_descriptor_discovery_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gatt_client interface rpc_client_attr_read function client shim.
RPC_T_GAP_CAUSE rpc_client_attr_read(uint8_t conn_id, uint8_t client_id, uint16_t handle)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gatt_client_service_id, krpc_gatt_client_rpc_client_attr_read_id, request.getSequence());

        codec->write(conn_id);

        codec->write(client_id);

        codec->write(handle);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gatt_client_rpc_client_attr_read_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gatt_client interface rpc_client_attr_read_using_uuid function client shim.
RPC_T_GAP_CAUSE rpc_client_attr_read_using_uuid(uint8_t conn_id, uint8_t client_id, uint16_t start_handle, uint16_t end_handle, uint16_t uuid16, const uint8_t p_uuid128[16])
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gatt_client_service_id, krpc_gatt_client_rpc_client_attr_read_using_uuid_id, request.getSequence());

        codec->write(conn_id);

        codec->write(client_id);

        codec->write(start_handle);

        codec->write(end_handle);

        codec->write(uuid16);

        for (uint32_t arrayCount0 = 0; arrayCount0 < 16; ++arrayCount0)
        {
            codec->write(p_uuid128[arrayCount0]);
        }

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gatt_client_rpc_client_attr_read_using_uuid_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gatt_client interface rpc_client_attr_write function client shim.
RPC_T_GAP_CAUSE rpc_client_attr_write(uint8_t conn_id, uint8_t client_id, RPC_T_GATT_WRITE_TYPE write_type, uint16_t handle, const binary_t * data)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gatt_client_service_id, krpc_gatt_client_rpc_client_attr_write_id, request.getSequence());

        codec->write(conn_id);

        codec->write(client_id);

        codec->write(static_cast<int32_t>(write_type));

        codec->write(handle);

        write_binary_t_struct(codec, data);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gatt_client_rpc_client_attr_write_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gatt_client interface rpc_client_attr_ind_confirm function client shim.
RPC_T_GAP_CAUSE rpc_client_attr_ind_confirm(uint8_t conn_id)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gatt_client_service_id, krpc_gatt_client_rpc_client_attr_ind_confirm_id, request.getSequence());

        codec->write(conn_id);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gatt_client_rpc_client_attr_ind_confirm_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gatt_server interface rpc_ble_server_init function client shim.
bool rpc_ble_server_init(uint8_t num)
{
    erpc_status_t err = kErpcStatus_Success;

    bool result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gatt_server_service_id, krpc_gatt_server_rpc_ble_server_init_id, request.getSequence());

        codec->write(num);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gatt_server_rpc_ble_server_init_id);

    if (err)
    {
        return false;
    }

    return result;
}

// rpc_gatt_server interface rpc_ble_create_service function client shim.
uint8_t rpc_ble_create_service(const uint8_t uuid[16], uint8_t uuid_length, bool is_primary)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gatt_server_service_id, krpc_gatt_server_rpc_ble_create_service_id, request.getSequence());

        for (uint32_t arrayCount0 = 0; arrayCount0 < 16; ++arrayCount0)
        {
            codec->write(uuid[arrayCount0]);
        }

        codec->write(uuid_length);

        codec->write(is_primary);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gatt_server_rpc_ble_create_service_id);

    if (err)
    {
        return 0xFFU;
    }

    return result;
}

// rpc_gatt_server interface rpc_ble_delete_service function client shim.
bool rpc_ble_delete_service(uint8_t app_id)
{
    erpc_status_t err = kErpcStatus_Success;

    bool result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gatt_server_service_id, krpc_gatt_server_rpc_ble_delete_service_id, request.getSequence());

        codec->write(app_id);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gatt_server_rpc_ble_delete_service_id);

    if (err)
    {
        return false;
    }

    return result;
}

// rpc_gatt_server interface rpc_ble_service_start function client shim.
uint8_t rpc_ble_service_start(uint8_t app_id)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gatt_server_service_id, krpc_gatt_server_rpc_ble_service_start_id, request.getSequence());

        codec->write(app_id);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gatt_server_rpc_ble_service_start_id);

    if (err)
    {
        return 0xFFU;
    }

    return result;
}

// rpc_gatt_server interface rpc_ble_get_servie_handle function client shim.
uint8_t rpc_ble_get_servie_handle(uint8_t app_id)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gatt_server_service_id, krpc_gatt_server_rpc_ble_get_servie_handle_id, request.getSequence());

        codec->write(app_id);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gatt_server_rpc_ble_get_servie_handle_id);

    if (err)
    {
        return 0xFFU;
    }

    return result;
}

// rpc_gatt_server interface rpc_ble_create_char function client shim.
uint16_t rpc_ble_create_char(uint8_t app_id, const uint8_t uuid[16], uint8_t uuid_length, uint8_t properties, uint32_t permissions)
{
    erpc_status_t err = kErpcStatus_Success;

    uint16_t result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gatt_server_service_id, krpc_gatt_server_rpc_ble_create_char_id, request.getSequence());

        codec->write(app_id);

        for (uint32_t arrayCount0 = 0; arrayCount0 < 16; ++arrayCount0)
        {
            codec->write(uuid[arrayCount0]);
        }

        codec->write(uuid_length);

        codec->write(properties);

        codec->write(permissions);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gatt_server_rpc_ble_create_char_id);

    if (err)
    {
        return 0xFFFFU;
    }

    return result;
}

// rpc_gatt_server interface rpc_ble_create_desc function client shim.
uint16_t rpc_ble_create_desc(uint8_t app_id, uint16_t char_handle, const uint8_t uuid[16], uint8_t uuid_length, uint8_t flags, uint32_t permissions, uint16_t value_length, const binary_t * p_value)
{
    erpc_status_t err = kErpcStatus_Success;

    uint16_t result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gatt_server_service_id, krpc_gatt_server_rpc_ble_create_desc_id, request.getSequence());

        codec->write(app_id);

        codec->write(char_handle);

        for (uint32_t arrayCount0 = 0; arrayCount0 < 16; ++arrayCount0)
        {
            codec->write(uuid[arrayCount0]);
        }

        codec->write(uuid_length);

        codec->write(flags);

        codec->write(permissions);

        codec->write(value_length);

        if (p_value == NULL)
        {
            codec->writeNullFlag(true);
        }
        else
        {
            codec->writeNullFlag(false);
            write_binary_t_struct(codec, p_value);
        }

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gatt_server_rpc_ble_create_desc_id);

    if (err)
    {
        return 0xFFFFU;
    }

    return result;
}

// rpc_gatt_server interface rpc_server_send_data function client shim.
bool rpc_server_send_data(uint8_t conn_id, uint8_t service_id, uint16_t attrib_index, const binary_t * data, RPC_T_GATT_PDU_TYPE pdu_type)
{
    erpc_status_t err = kErpcStatus_Success;

    bool result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gatt_server_service_id, krpc_gatt_server_rpc_server_send_data_id, request.getSequence());

        codec->write(conn_id);

        codec->write(service_id);

        codec->write(attrib_index);

        write_binary_t_struct(codec, data);

        codec->write(static_cast<int32_t>(pdu_type));

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gatt_server_rpc_server_send_data_id);

    if (err)
    {
        return false;
    }

    return result;
}

// rpc_gatt_server interface rpc_ble_server_get_attr_value function client shim.
binary_t * rpc_ble_server_get_attr_value(uint8_t app_id, uint16_t attr_handle)
{
    erpc_status_t err = kErpcStatus_Success;

    binary_t * result = NULL;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gatt_server_service_id, krpc_gatt_server_rpc_ble_server_get_attr_value_id, request.getSequence());

        codec->write(app_id);

        codec->write(attr_handle);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        bool isNull;
        codec->readNullFlag(&isNull);
        if (!isNull)
        {
            result = (binary_t *) erpc_malloc(sizeof(binary_t));
            if (result == NULL)
            {
                codec->updateStatus(kErpcStatus_MemoryError);
            }
            read_binary_t_struct(codec, result);
        }
        else
        {
            result = NULL;
        }

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gatt_server_rpc_ble_server_get_attr_value_id);

    return result;
}

// rpc_gatt_server interface rpc_server_exec_write_confirm function client shim.
bool rpc_server_exec_write_confirm(uint8_t conn_id, uint16_t cause, uint16_t handle)
{
    erpc_status_t err = kErpcStatus_Success;

    bool result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gatt_server_service_id, krpc_gatt_server_rpc_server_exec_write_confirm_id, request.getSequence());

        codec->write(conn_id);

        codec->write(cause);

        codec->write(handle);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gatt_server_rpc_server_exec_write_confirm_id);

    if (err)
    {
        return false;
    }

    return result;
}

// rpc_gatt_server interface rpc_server_attr_write_confirm function client shim.
bool rpc_server_attr_write_confirm(uint8_t conn_id, uint8_t service_id, uint16_t attrib_index, RPC_T_APP_RESULT cause)
{
    erpc_status_t err = kErpcStatus_Success;

    bool result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gatt_server_service_id, krpc_gatt_server_rpc_server_attr_write_confirm_id, request.getSequence());

        codec->write(conn_id);

        codec->write(service_id);

        codec->write(attrib_index);

        codec->write(static_cast<int32_t>(cause));

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gatt_server_rpc_server_attr_write_confirm_id);

    if (err)
    {
        return false;
    }

    return result;
}

// rpc_gatt_server interface rpc_server_attr_read_confirm function client shim.
bool rpc_server_attr_read_confirm(uint8_t conn_id, uint8_t service_id, uint16_t attrib_index, const binary_t * data, RPC_T_APP_RESULT cause)
{
    erpc_status_t err = kErpcStatus_Success;

    bool result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gatt_server_service_id, krpc_gatt_server_rpc_server_attr_read_confirm_id, request.getSequence());

        codec->write(conn_id);

        codec->write(service_id);

        codec->write(attrib_index);

        write_binary_t_struct(codec, data);

        codec->write(static_cast<int32_t>(cause));

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gatt_server_rpc_server_attr_read_confirm_id);

    if (err)
    {
        return false;
    }

    return result;
}
