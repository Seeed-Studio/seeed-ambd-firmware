/*
 * Generated by erpcgen 1.7.4 on Tue Nov  3 15:03:59 2020.
 *
 * AUTOGENERATED - DO NOT EDIT
 */


#include "rpc_wifi_api_server.h"
#include <new>
#include "erpc_port.h"
#include "erpc_manually_constructed.h"

#if 10704 != ERPC_VERSION_NUMBER
#error "The generated shim code version is different to the rest of eRPC code."
#endif

using namespace erpc;
using namespace std;

#if ERPC_NESTED_CALLS_DETECTION
extern bool nestingDetection;
#endif

static ManuallyConstructed<rpc_wifi_drv_service> s_rpc_wifi_drv_service;

static ManuallyConstructed<rpc_wifi_tcpip_service> s_rpc_wifi_tcpip_service;

static ManuallyConstructed<rpc_wifi_lwip_service> s_rpc_wifi_lwip_service;

static ManuallyConstructed<rpc_wifi_mbedtls_service> s_rpc_wifi_mbedtls_service;


//! @brief Function to read struct binary_t
static void read_binary_t_struct(erpc::Codec * codec, binary_t * data);


// Read struct binary_t function implementation
static void read_binary_t_struct(erpc::Codec * codec, binary_t * data)
{
    uint8_t * data_local;
    codec->readBinary(&data->dataLength, &data_local);
    data->data = (uint8_t *) erpc_malloc(data->dataLength * sizeof(uint8_t));
    if (data->data == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    else
    {
        memcpy(data->data, data_local, data->dataLength);
    }
}


//! @brief Function to write struct binary_t
static void write_binary_t_struct(erpc::Codec * codec, const binary_t * data);


// Write struct binary_t function implementation
static void write_binary_t_struct(erpc::Codec * codec, const binary_t * data)
{
    codec->writeBinary(data->dataLength, data->data);
}


//! @brief Function to free space allocated inside struct binary_t
static void free_binary_t_struct(binary_t * data);


// Free space allocated inside struct binary_t function implementation
static void free_binary_t_struct(binary_t * data)
{
    if (data->data)
    {
        erpc_free(data->data);
    }
}



// Call the correct server shim based on method unique ID.
erpc_status_t rpc_wifi_drv_service::handleInvocation(uint32_t methodId, uint32_t sequence, Codec * codec, MessageBufferFactory *messageFactory)
{
    switch (methodId)
    {
        case krpc_wifi_drv_rpc_wifi_connect_id:
            return rpc_wifi_connect_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_connect_bssid_id:
            return rpc_wifi_connect_bssid_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_disconnect_id:
            return rpc_wifi_disconnect_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_is_connected_to_ap_id:
            return rpc_wifi_is_connected_to_ap_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_is_up_id:
            return rpc_wifi_is_up_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_is_ready_to_transceive_id:
            return rpc_wifi_is_ready_to_transceive_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_mac_address_id:
            return rpc_wifi_set_mac_address_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_get_mac_address_id:
            return rpc_wifi_get_mac_address_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_enable_powersave_id:
            return rpc_wifi_enable_powersave_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_resume_powersave_id:
            return rpc_wifi_resume_powersave_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_disable_powersave_id:
            return rpc_wifi_disable_powersave_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_btcoex_set_bt_on_id:
            return rpc_wifi_btcoex_set_bt_on_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_btcoex_set_bt_off_id:
            return rpc_wifi_btcoex_set_bt_off_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_get_associated_client_list_id:
            return rpc_wifi_get_associated_client_list_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_get_ap_bssid_id:
            return rpc_wifi_get_ap_bssid_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_get_ap_info_id:
            return rpc_wifi_get_ap_info_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_country_id:
            return rpc_wifi_set_country_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_get_sta_max_data_rate_id:
            return rpc_wifi_get_sta_max_data_rate_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_get_rssi_id:
            return rpc_wifi_get_rssi_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_channel_id:
            return rpc_wifi_set_channel_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_get_channel_id:
            return rpc_wifi_get_channel_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_change_channel_plan_id:
            return rpc_wifi_change_channel_plan_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_register_multicast_address_id:
            return rpc_wifi_register_multicast_address_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_unregister_multicast_address_id:
            return rpc_wifi_unregister_multicast_address_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_rf_on_id:
            return rpc_wifi_rf_on_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_rf_off_id:
            return rpc_wifi_rf_off_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_on_id:
            return rpc_wifi_on_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_off_id:
            return rpc_wifi_off_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_mode_id:
            return rpc_wifi_set_mode_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_off_fastly_id:
            return rpc_wifi_off_fastly_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_power_mode_id:
            return rpc_wifi_set_power_mode_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_tdma_param_id:
            return rpc_wifi_set_tdma_param_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_lps_dtim_id:
            return rpc_wifi_set_lps_dtim_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_get_lps_dtim_id:
            return rpc_wifi_get_lps_dtim_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_lps_thresh_id:
            return rpc_wifi_set_lps_thresh_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_lps_level_id:
            return rpc_wifi_set_lps_level_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_mfp_support_id:
            return rpc_wifi_set_mfp_support_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_start_ap_id:
            return rpc_wifi_start_ap_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_start_ap_with_hidden_ssid_id:
            return rpc_wifi_start_ap_with_hidden_ssid_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_pscan_chan_id:
            return rpc_wifi_set_pscan_chan_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_get_setting_id:
            return rpc_wifi_get_setting_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_network_mode_id:
            return rpc_wifi_set_network_mode_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_get_network_mode_id:
            return rpc_wifi_get_network_mode_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_wps_phase_id:
            return rpc_wifi_set_wps_phase_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_restart_ap_id:
            return rpc_wifi_restart_ap_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_config_autoreconnect_id:
            return rpc_wifi_config_autoreconnect_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_autoreconnect_id:
            return rpc_wifi_set_autoreconnect_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_get_autoreconnect_id:
            return rpc_wifi_get_autoreconnect_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_get_last_error_id:
            return rpc_wifi_get_last_error_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_add_custom_ie_id:
            return rpc_wifi_add_custom_ie_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_update_custom_ie_id:
            return rpc_wifi_update_custom_ie_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_del_custom_ie_id:
            return rpc_wifi_del_custom_ie_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_indicate_mgnt_id:
            return rpc_wifi_set_indicate_mgnt_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_get_drv_ability_id:
            return rpc_wifi_get_drv_ability_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_channel_plan_id:
            return rpc_wifi_set_channel_plan_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_get_channel_plan_id:
            return rpc_wifi_get_channel_plan_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_enable_forwarding_id:
            return rpc_wifi_enable_forwarding_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_disable_forwarding_id:
            return rpc_wifi_disable_forwarding_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_ch_deauth_id:
            return rpc_wifi_set_ch_deauth_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_get_band_type_id:
            return rpc_wifi_get_band_type_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_set_tx_pause_data_id:
            return rpc_wifi_set_tx_pause_data_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_get_reconnect_data_id:
            return rpc_wifi_get_reconnect_data_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_scan_start_id:
            return rpc_wifi_scan_start_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_is_scaning_id:
            return rpc_wifi_is_scaning_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_scan_get_ap_records_id:
            return rpc_wifi_scan_get_ap_records_shim(codec, messageFactory, sequence);

        case krpc_wifi_drv_rpc_wifi_scan_get_ap_num_id:
            return rpc_wifi_scan_get_ap_num_shim(codec, messageFactory, sequence);

        default:
            return kErpcStatus_InvalidArgument;
    }
}

// Server shim for rpc_wifi_connect of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_connect_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    char * ssid = NULL;
    char * password = NULL;
    uint32_t security_type;
    int32_t key_id;
    uint32_t semaphore;
    bool isNull;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    uint32_t ssid_len;
    char * ssid_local;
    codec->readString(&ssid_len, &ssid_local);
    ssid = (char *) erpc_malloc((ssid_len + 1) * sizeof(char));
    if (ssid == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    else
    {
        memcpy(ssid, ssid_local, ssid_len);
        (ssid)[ssid_len] = 0;
    }

    codec->readNullFlag(&isNull);
    if (!isNull)
    {
        uint32_t password_len;
        char * password_local;
        codec->readString(&password_len, &password_local);
        password = (char *) erpc_malloc((password_len + 1) * sizeof(char));
        if (password == NULL)
        {
            codec->updateStatus(kErpcStatus_MemoryError);
        }
        else
        {
            memcpy(password, password_local, password_len);
            (password)[password_len] = 0;
        }
    }
    else
    {
        password = NULL;
    }

    codec->read(&security_type);

    codec->read(&key_id);

    codec->read(&semaphore);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_connect(ssid, password, security_type, key_id, semaphore);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_connect_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (ssid)
    {
        erpc_free(ssid);
    }

    if (password)
    {
        erpc_free(password);
    }

    return err;
}

// Server shim for rpc_wifi_connect_bssid of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_connect_bssid_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    binary_t *bssid = NULL;
    bssid = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (bssid == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    char * ssid = NULL;
    char * password = NULL;
    uint32_t security_type;
    int32_t key_id;
    uint32_t semaphore;
    bool isNull;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_binary_t_struct(codec, bssid);

    codec->readNullFlag(&isNull);
    if (!isNull)
    {
        uint32_t ssid_len;
        char * ssid_local;
        codec->readString(&ssid_len, &ssid_local);
        ssid = (char *) erpc_malloc((ssid_len + 1) * sizeof(char));
        if (ssid == NULL)
        {
            codec->updateStatus(kErpcStatus_MemoryError);
        }
        else
        {
            memcpy(ssid, ssid_local, ssid_len);
            (ssid)[ssid_len] = 0;
        }
    }
    else
    {
        ssid = NULL;
    }

    uint32_t password_len;
    char * password_local;
    codec->readString(&password_len, &password_local);
    password = (char *) erpc_malloc((password_len + 1) * sizeof(char));
    if (password == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    else
    {
        memcpy(password, password_local, password_len);
        (password)[password_len] = 0;
    }

    codec->read(&security_type);

    codec->read(&key_id);

    codec->read(&semaphore);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_connect_bssid(bssid, ssid, password, security_type, key_id, semaphore);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_connect_bssid_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (bssid)
    {
        free_binary_t_struct(bssid);
    }
    if (bssid)
    {
        erpc_free(bssid);
    }

    if (ssid)
    {
        erpc_free(ssid);
    }

    if (password)
    {
        erpc_free(password);
    }

    return err;
}

// Server shim for rpc_wifi_disconnect of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_disconnect_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_disconnect();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_disconnect_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_is_connected_to_ap of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_is_connected_to_ap_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_is_connected_to_ap();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_is_connected_to_ap_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_is_up of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_is_up_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t itf;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&itf);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_is_up(itf);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_is_up_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_is_ready_to_transceive of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_is_ready_to_transceive_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t itf;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&itf);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_is_ready_to_transceive(itf);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_is_ready_to_transceive_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_set_mac_address of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_mac_address_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    binary_t *mac = NULL;
    mac = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (mac == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_binary_t_struct(codec, mac);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_set_mac_address(mac);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_mac_address_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (mac)
    {
        free_binary_t_struct(mac);
    }
    if (mac)
    {
        erpc_free(mac);
    }

    return err;
}

// Server shim for rpc_wifi_get_mac_address of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_get_mac_address_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t mac[18];
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_get_mac_address(mac);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_get_mac_address_id, sequence);

        for (uint32_t arrayCount0 = 0; arrayCount0 < 18; ++arrayCount0)
        {
            codec->write(mac[arrayCount0]);
        }

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_enable_powersave of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_enable_powersave_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_enable_powersave();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_enable_powersave_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_resume_powersave of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_resume_powersave_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_resume_powersave();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_resume_powersave_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_disable_powersave of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_disable_powersave_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_disable_powersave();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_disable_powersave_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_btcoex_set_bt_on of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_btcoex_set_bt_on_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;


    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        rpc_wifi_btcoex_set_bt_on();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_btcoex_set_bt_on_id, sequence);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_btcoex_set_bt_off of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_btcoex_set_bt_off_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;


    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        rpc_wifi_btcoex_set_bt_off();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_btcoex_set_bt_off_id, sequence);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_get_associated_client_list of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_get_associated_client_list_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    binary_t *client_list_buffer = NULL;
    uint16_t buffer_length;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&buffer_length);

    client_list_buffer = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (client_list_buffer == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_get_associated_client_list(client_list_buffer, buffer_length);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_get_associated_client_list_id, sequence);

        write_binary_t_struct(codec, client_list_buffer);

        codec->write(result);

        err = codec->getStatus();
    }

    if (client_list_buffer)
    {
        free_binary_t_struct(client_list_buffer);
    }
    if (client_list_buffer)
    {
        erpc_free(client_list_buffer);
    }

    return err;
}

// Server shim for rpc_wifi_get_ap_bssid of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_get_ap_bssid_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t bssid[6];
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_get_ap_bssid(bssid);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_get_ap_bssid_id, sequence);

        for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
        {
            codec->write(bssid[arrayCount0]);
        }

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_get_ap_info of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_get_ap_info_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    binary_t *ap_info = NULL;
    uint32_t security;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    ap_info = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (ap_info == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_get_ap_info(ap_info, &security);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_get_ap_info_id, sequence);

        write_binary_t_struct(codec, ap_info);

        codec->write(security);

        codec->write(result);

        err = codec->getStatus();
    }

    if (ap_info)
    {
        free_binary_t_struct(ap_info);
    }
    if (ap_info)
    {
        erpc_free(ap_info);
    }

    return err;
}

// Server shim for rpc_wifi_set_country of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_country_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t country_code;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&country_code);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_set_country(country_code);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_country_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_get_sta_max_data_rate of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_get_sta_max_data_rate_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t inidata_rate;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_get_sta_max_data_rate(&inidata_rate);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_get_sta_max_data_rate_id, sequence);

        codec->write(inidata_rate);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_get_rssi of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_get_rssi_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t pRSSI;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_get_rssi(&pRSSI);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_get_rssi_id, sequence);

        codec->write(pRSSI);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_set_channel of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_channel_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t channel;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&channel);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_set_channel(channel);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_channel_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_get_channel of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_get_channel_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t channel;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_get_channel(&channel);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_get_channel_id, sequence);

        codec->write(channel);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_change_channel_plan of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_change_channel_plan_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t channel_plan;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&channel_plan);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_change_channel_plan(channel_plan);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_change_channel_plan_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_register_multicast_address of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_register_multicast_address_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t mac[6];
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
    {
        codec->read(&mac[arrayCount0]);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_register_multicast_address(mac);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_register_multicast_address_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_unregister_multicast_address of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_unregister_multicast_address_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t mac[6];
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    for (uint32_t arrayCount0 = 0; arrayCount0 < 6; ++arrayCount0)
    {
        codec->read(&mac[arrayCount0]);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_unregister_multicast_address(mac);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_unregister_multicast_address_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_rf_on of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_rf_on_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_rf_on();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_rf_on_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_rf_off of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_rf_off_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_rf_off();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_rf_off_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_on of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_on_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t mode;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&mode);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_on(mode);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_on_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_off of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_off_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_off();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_off_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_set_mode of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_mode_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t mode;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&mode);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_set_mode(mode);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_mode_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_off_fastly of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_off_fastly_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_off_fastly();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_off_fastly_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_set_power_mode of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_power_mode_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t ips_mode;
    uint8_t lps_mode;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&ips_mode);

    codec->read(&lps_mode);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_set_power_mode(ips_mode, lps_mode);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_power_mode_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_set_tdma_param of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_tdma_param_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t slot_period;
    uint8_t rfon_period_len_1;
    uint8_t rfon_period_len_2;
    uint8_t rfon_period_len_3;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&slot_period);

    codec->read(&rfon_period_len_1);

    codec->read(&rfon_period_len_2);

    codec->read(&rfon_period_len_3);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_set_tdma_param(slot_period, rfon_period_len_1, rfon_period_len_2, rfon_period_len_3);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_tdma_param_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_set_lps_dtim of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_lps_dtim_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t dtim;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&dtim);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_set_lps_dtim(dtim);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_lps_dtim_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_get_lps_dtim of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_get_lps_dtim_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t dtim;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_get_lps_dtim(&dtim);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_get_lps_dtim_id, sequence);

        codec->write(dtim);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_set_lps_thresh of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_lps_thresh_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t mode;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&mode);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_set_lps_thresh(mode);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_lps_thresh_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_set_lps_level of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_lps_level_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t lps_level;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&lps_level);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_set_lps_level(lps_level);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_lps_level_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_set_mfp_support of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_mfp_support_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t value;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&value);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_set_mfp_support(value);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_mfp_support_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_start_ap of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_start_ap_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    binary_t *ssid = NULL;
    ssid = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (ssid == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    binary_t *password = NULL;
    password = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (password == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    uint32_t security_type;
    int32_t channel;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_binary_t_struct(codec, ssid);

    read_binary_t_struct(codec, password);

    codec->read(&security_type);

    codec->read(&channel);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_start_ap(ssid, password, security_type, channel);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_start_ap_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (ssid)
    {
        free_binary_t_struct(ssid);
    }
    if (ssid)
    {
        erpc_free(ssid);
    }

    if (password)
    {
        free_binary_t_struct(password);
    }
    if (password)
    {
        erpc_free(password);
    }

    return err;
}

// Server shim for rpc_wifi_start_ap_with_hidden_ssid of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_start_ap_with_hidden_ssid_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    binary_t *ssid = NULL;
    ssid = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (ssid == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    binary_t *password = NULL;
    password = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (password == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    uint32_t security_type;
    int32_t channel;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_binary_t_struct(codec, ssid);

    read_binary_t_struct(codec, password);

    codec->read(&security_type);

    codec->read(&channel);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_start_ap_with_hidden_ssid(ssid, password, security_type, channel);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_start_ap_with_hidden_ssid_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (ssid)
    {
        free_binary_t_struct(ssid);
    }
    if (ssid)
    {
        erpc_free(ssid);
    }

    if (password)
    {
        free_binary_t_struct(password);
    }
    if (password)
    {
        erpc_free(password);
    }

    return err;
}

// Server shim for rpc_wifi_set_pscan_chan of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_pscan_chan_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    binary_t *channel_list = NULL;
    channel_list = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (channel_list == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    uint8_t pscan_config;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_binary_t_struct(codec, channel_list);

    codec->read(&pscan_config);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_set_pscan_chan(channel_list, pscan_config);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_pscan_chan_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (channel_list)
    {
        free_binary_t_struct(channel_list);
    }
    if (channel_list)
    {
        erpc_free(channel_list);
    }

    return err;
}

// Server shim for rpc_wifi_get_setting of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_get_setting_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    char * ifname = NULL;
    binary_t *pSetting = NULL;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    uint32_t ifname_len;
    char * ifname_local;
    codec->readString(&ifname_len, &ifname_local);
    ifname = (char *) erpc_malloc((ifname_len + 1) * sizeof(char));
    if (ifname == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    else
    {
        memcpy(ifname, ifname_local, ifname_len);
        (ifname)[ifname_len] = 0;
    }

    pSetting = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (pSetting == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_get_setting(ifname, pSetting);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_get_setting_id, sequence);

        write_binary_t_struct(codec, pSetting);

        codec->write(result);

        err = codec->getStatus();
    }

    if (ifname)
    {
        erpc_free(ifname);
    }

    if (pSetting)
    {
        free_binary_t_struct(pSetting);
    }
    if (pSetting)
    {
        erpc_free(pSetting);
    }

    return err;
}

// Server shim for rpc_wifi_set_network_mode of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_network_mode_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t mode;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&mode);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_set_network_mode(mode);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_network_mode_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_get_network_mode of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_get_network_mode_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t pmode;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_get_network_mode(&pmode);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_get_network_mode_id, sequence);

        codec->write(pmode);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_set_wps_phase of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_wps_phase_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t is_trigger_wps;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&is_trigger_wps);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_set_wps_phase(is_trigger_wps);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_wps_phase_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_restart_ap of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_restart_ap_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    binary_t *ssid = NULL;
    ssid = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (ssid == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    binary_t *password = NULL;
    password = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (password == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    uint32_t security_type;
    int32_t channel;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_binary_t_struct(codec, ssid);

    read_binary_t_struct(codec, password);

    codec->read(&security_type);

    codec->read(&channel);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_restart_ap(ssid, password, security_type, channel);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_restart_ap_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (ssid)
    {
        free_binary_t_struct(ssid);
    }
    if (ssid)
    {
        erpc_free(ssid);
    }

    if (password)
    {
        free_binary_t_struct(password);
    }
    if (password)
    {
        erpc_free(password);
    }

    return err;
}

// Server shim for rpc_wifi_config_autoreconnect of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_config_autoreconnect_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t mode;
    uint8_t retry_times;
    uint16_t timeout;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&mode);

    codec->read(&retry_times);

    codec->read(&timeout);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_config_autoreconnect(mode, retry_times, timeout);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_config_autoreconnect_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_set_autoreconnect of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_autoreconnect_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t mode;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&mode);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_set_autoreconnect(mode);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_autoreconnect_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_get_autoreconnect of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_get_autoreconnect_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t mode;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_get_autoreconnect(&mode);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_get_autoreconnect_id, sequence);

        codec->write(mode);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_get_last_error of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_get_last_error_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_get_last_error();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_get_last_error_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_add_custom_ie of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_add_custom_ie_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    binary_t *cus_ie = NULL;
    cus_ie = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (cus_ie == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_binary_t_struct(codec, cus_ie);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_add_custom_ie(cus_ie);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_add_custom_ie_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (cus_ie)
    {
        free_binary_t_struct(cus_ie);
    }
    if (cus_ie)
    {
        erpc_free(cus_ie);
    }

    return err;
}

// Server shim for rpc_wifi_update_custom_ie of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_update_custom_ie_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    binary_t *cus_ie = NULL;
    cus_ie = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (cus_ie == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t ie_index;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_binary_t_struct(codec, cus_ie);

    codec->read(&ie_index);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_update_custom_ie(cus_ie, ie_index);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_update_custom_ie_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (cus_ie)
    {
        free_binary_t_struct(cus_ie);
    }
    if (cus_ie)
    {
        erpc_free(cus_ie);
    }

    return err;
}

// Server shim for rpc_wifi_del_custom_ie of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_del_custom_ie_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_del_custom_ie();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_del_custom_ie_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_set_indicate_mgnt of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_indicate_mgnt_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t enable;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&enable);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        rpc_wifi_set_indicate_mgnt(enable);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_indicate_mgnt_id, sequence);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_get_drv_ability of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_get_drv_ability_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t ability;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_get_drv_ability(&ability);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_get_drv_ability_id, sequence);

        codec->write(ability);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_set_channel_plan of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_channel_plan_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t channel_plan;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&channel_plan);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_set_channel_plan(channel_plan);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_channel_plan_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_get_channel_plan of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_get_channel_plan_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t channel_plan;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_get_channel_plan(&channel_plan);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_get_channel_plan_id, sequence);

        codec->write(channel_plan);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_enable_forwarding of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_enable_forwarding_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_enable_forwarding();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_enable_forwarding_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_disable_forwarding of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_disable_forwarding_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_disable_forwarding();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_disable_forwarding_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_set_ch_deauth of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_ch_deauth_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t enable;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&enable);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_set_ch_deauth(enable);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_ch_deauth_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_get_band_type of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_get_band_type_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_get_band_type();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_get_band_type_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_set_tx_pause_data of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_set_tx_pause_data_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t NewState;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&NewState);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_set_tx_pause_data(NewState);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_set_tx_pause_data_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_get_reconnect_data of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_get_reconnect_data_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    binary_t *wifi_info = NULL;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    wifi_info = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (wifi_info == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_get_reconnect_data(wifi_info);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_get_reconnect_data_id, sequence);

        write_binary_t_struct(codec, wifi_info);

        codec->write(result);

        err = codec->getStatus();
    }

    if (wifi_info)
    {
        free_binary_t_struct(wifi_info);
    }
    if (wifi_info)
    {
        erpc_free(wifi_info);
    }

    return err;
}

// Server shim for rpc_wifi_scan_start of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_scan_start_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_scan_start();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_scan_start_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_is_scaning of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_is_scaning_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    bool result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_is_scaning();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_is_scaning_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_scan_get_ap_records of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_scan_get_ap_records_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint16_t number;
    binary_t *_scanResult = NULL;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&number);

    _scanResult = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (_scanResult == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_scan_get_ap_records(number, _scanResult);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_scan_get_ap_records_id, sequence);

        write_binary_t_struct(codec, _scanResult);

        codec->write(result);

        err = codec->getStatus();
    }

    if (_scanResult)
    {
        free_binary_t_struct(_scanResult);
    }
    if (_scanResult)
    {
        erpc_free(_scanResult);
    }

    return err;
}

// Server shim for rpc_wifi_scan_get_ap_num of rpc_wifi_drv interface.
erpc_status_t rpc_wifi_drv_service::rpc_wifi_scan_get_ap_num_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint16_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_scan_get_ap_num();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_drv_service_id, krpc_wifi_drv_rpc_wifi_scan_get_ap_num_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Call the correct server shim based on method unique ID.
erpc_status_t rpc_wifi_tcpip_service::handleInvocation(uint32_t methodId, uint32_t sequence, Codec * codec, MessageBufferFactory *messageFactory)
{
    switch (methodId)
    {
        case krpc_wifi_tcpip_rpc_tcpip_adapter_init_id:
            return rpc_tcpip_adapter_init_shim(codec, messageFactory, sequence);

        case krpc_wifi_tcpip_rpc_tcpip_adapter_sta_start_id:
            return rpc_tcpip_adapter_sta_start_shim(codec, messageFactory, sequence);

        case krpc_wifi_tcpip_rpc_tcpip_adapter_ap_start_id:
            return rpc_tcpip_adapter_ap_start_shim(codec, messageFactory, sequence);

        case krpc_wifi_tcpip_rpc_tcpip_adapter_stop_id:
            return rpc_tcpip_adapter_stop_shim(codec, messageFactory, sequence);

        case krpc_wifi_tcpip_rpc_tcpip_adapter_up_id:
            return rpc_tcpip_adapter_up_shim(codec, messageFactory, sequence);

        case krpc_wifi_tcpip_rpc_tcpip_adapter_down_id:
            return rpc_tcpip_adapter_down_shim(codec, messageFactory, sequence);

        case krpc_wifi_tcpip_rpc_tcpip_adapter_get_ip_info_id:
            return rpc_tcpip_adapter_get_ip_info_shim(codec, messageFactory, sequence);

        case krpc_wifi_tcpip_rpc_tcpip_adapter_set_ip_info_id:
            return rpc_tcpip_adapter_set_ip_info_shim(codec, messageFactory, sequence);

        case krpc_wifi_tcpip_rpc_tcpip_adapter_set_dns_info_id:
            return rpc_tcpip_adapter_set_dns_info_shim(codec, messageFactory, sequence);

        case krpc_wifi_tcpip_rpc_tcpip_adapter_get_dns_info_id:
            return rpc_tcpip_adapter_get_dns_info_shim(codec, messageFactory, sequence);

        case krpc_wifi_tcpip_rpc_tcpip_adapter_dhcps_start_id:
            return rpc_tcpip_adapter_dhcps_start_shim(codec, messageFactory, sequence);

        case krpc_wifi_tcpip_rpc_tcpip_adapter_dhcps_stop_id:
            return rpc_tcpip_adapter_dhcps_stop_shim(codec, messageFactory, sequence);

        case krpc_wifi_tcpip_rpc_tcpip_adapter_dhcpc_start_id:
            return rpc_tcpip_adapter_dhcpc_start_shim(codec, messageFactory, sequence);

        case krpc_wifi_tcpip_rpc_tcpip_adapter_dhcpc_stop_id:
            return rpc_tcpip_adapter_dhcpc_stop_shim(codec, messageFactory, sequence);

        case krpc_wifi_tcpip_rpc_tcpip_adapter_set_hostname_id:
            return rpc_tcpip_adapter_set_hostname_shim(codec, messageFactory, sequence);

        case krpc_wifi_tcpip_rpc_tcpip_adapter_get_hostname_id:
            return rpc_tcpip_adapter_get_hostname_shim(codec, messageFactory, sequence);

        case krpc_wifi_tcpip_rpc_tcpip_adapter_get_mac_id:
            return rpc_tcpip_adapter_get_mac_shim(codec, messageFactory, sequence);

        case krpc_wifi_tcpip_rpc_tcpip_adapter_set_mac_id:
            return rpc_tcpip_adapter_set_mac_shim(codec, messageFactory, sequence);

        default:
            return kErpcStatus_InvalidArgument;
    }
}

// Server shim for rpc_tcpip_adapter_init of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_init_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_init();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_init_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_tcpip_adapter_sta_start of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_sta_start_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    binary_t *mac = NULL;
    mac = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (mac == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    binary_t *ip_info = NULL;
    ip_info = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (ip_info == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_binary_t_struct(codec, mac);

    read_binary_t_struct(codec, ip_info);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_sta_start(mac, ip_info);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_sta_start_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (mac)
    {
        free_binary_t_struct(mac);
    }
    if (mac)
    {
        erpc_free(mac);
    }

    if (ip_info)
    {
        free_binary_t_struct(ip_info);
    }
    if (ip_info)
    {
        erpc_free(ip_info);
    }

    return err;
}

// Server shim for rpc_tcpip_adapter_ap_start of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_ap_start_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    binary_t *mac = NULL;
    mac = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (mac == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    binary_t *ip_info = NULL;
    ip_info = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (ip_info == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_binary_t_struct(codec, mac);

    read_binary_t_struct(codec, ip_info);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_ap_start(mac, ip_info);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_ap_start_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (mac)
    {
        free_binary_t_struct(mac);
    }
    if (mac)
    {
        erpc_free(mac);
    }

    if (ip_info)
    {
        free_binary_t_struct(ip_info);
    }
    if (ip_info)
    {
        erpc_free(ip_info);
    }

    return err;
}

// Server shim for rpc_tcpip_adapter_stop of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_stop_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t tcpip_if;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&tcpip_if);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_stop(tcpip_if);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_stop_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_tcpip_adapter_up of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_up_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t tcpip_if;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&tcpip_if);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_up(tcpip_if);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_up_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_tcpip_adapter_down of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_down_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t tcpip_if;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&tcpip_if);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_down(tcpip_if);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_down_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_tcpip_adapter_get_ip_info of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_get_ip_info_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t tcpip_if;
    binary_t *ip_info = NULL;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&tcpip_if);

    ip_info = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (ip_info == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_get_ip_info(tcpip_if, ip_info);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_get_ip_info_id, sequence);

        write_binary_t_struct(codec, ip_info);

        codec->write(result);

        err = codec->getStatus();
    }

    if (ip_info)
    {
        free_binary_t_struct(ip_info);
    }
    if (ip_info)
    {
        erpc_free(ip_info);
    }

    return err;
}

// Server shim for rpc_tcpip_adapter_set_ip_info of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_set_ip_info_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t tcpip_if;
    binary_t *ip_info = NULL;
    ip_info = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (ip_info == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&tcpip_if);

    read_binary_t_struct(codec, ip_info);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_set_ip_info(tcpip_if, ip_info);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_set_ip_info_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (ip_info)
    {
        free_binary_t_struct(ip_info);
    }
    if (ip_info)
    {
        erpc_free(ip_info);
    }

    return err;
}

// Server shim for rpc_tcpip_adapter_set_dns_info of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_set_dns_info_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t tcpip_if;
    uint32_t dns_type;
    binary_t *dns = NULL;
    dns = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (dns == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&tcpip_if);

    codec->read(&dns_type);

    read_binary_t_struct(codec, dns);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_set_dns_info(tcpip_if, dns_type, dns);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_set_dns_info_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (dns)
    {
        free_binary_t_struct(dns);
    }
    if (dns)
    {
        erpc_free(dns);
    }

    return err;
}

// Server shim for rpc_tcpip_adapter_get_dns_info of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_get_dns_info_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t tcpip_if;
    uint32_t dns_type;
    binary_t *dns = NULL;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&tcpip_if);

    codec->read(&dns_type);

    dns = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (dns == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_get_dns_info(tcpip_if, dns_type, dns);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_get_dns_info_id, sequence);

        write_binary_t_struct(codec, dns);

        codec->write(result);

        err = codec->getStatus();
    }

    if (dns)
    {
        free_binary_t_struct(dns);
    }
    if (dns)
    {
        erpc_free(dns);
    }

    return err;
}

// Server shim for rpc_tcpip_adapter_dhcps_start of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_dhcps_start_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t tcpip_if;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&tcpip_if);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_dhcps_start(tcpip_if);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_dhcps_start_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_tcpip_adapter_dhcps_stop of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_dhcps_stop_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t tcpip_if;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&tcpip_if);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_dhcps_stop(tcpip_if);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_dhcps_stop_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_tcpip_adapter_dhcpc_start of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_dhcpc_start_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t tcpip_if;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&tcpip_if);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_dhcpc_start(tcpip_if);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_dhcpc_start_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_tcpip_adapter_dhcpc_stop of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_dhcpc_stop_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t tcpip_if;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&tcpip_if);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_dhcpc_stop(tcpip_if);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_dhcpc_stop_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_tcpip_adapter_set_hostname of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_set_hostname_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t tcpip_if;
    char * hostname = NULL;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&tcpip_if);

    uint32_t hostname_len;
    char * hostname_local;
    codec->readString(&hostname_len, &hostname_local);
    hostname = (char *) erpc_malloc((hostname_len + 1) * sizeof(char));
    if (hostname == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    else
    {
        memcpy(hostname, hostname_local, hostname_len);
        (hostname)[hostname_len] = 0;
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_set_hostname(tcpip_if, hostname);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_set_hostname_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (hostname)
    {
        erpc_free(hostname);
    }

    return err;
}

// Server shim for rpc_tcpip_adapter_get_hostname of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_get_hostname_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t tcpip_if;
    char * hostname = NULL;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&tcpip_if);

    hostname = (char *) erpc_malloc((32 + 1) * sizeof(char));
    if (hostname == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    else
    {
        hostname[32] = '\0';
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_get_hostname(tcpip_if, hostname);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_get_hostname_id, sequence);

        codec->writeString(strlen(hostname), hostname);

        codec->write(result);

        err = codec->getStatus();
    }

    if (hostname)
    {
        erpc_free(hostname);
    }

    return err;
}

// Server shim for rpc_tcpip_adapter_get_mac of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_get_mac_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t tcpip_if;
    binary_t *mac = NULL;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&tcpip_if);

    mac = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (mac == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_get_mac(tcpip_if, mac);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_get_mac_id, sequence);

        write_binary_t_struct(codec, mac);

        codec->write(result);

        err = codec->getStatus();
    }

    if (mac)
    {
        free_binary_t_struct(mac);
    }
    if (mac)
    {
        erpc_free(mac);
    }

    return err;
}

// Server shim for rpc_tcpip_adapter_set_mac of rpc_wifi_tcpip interface.
erpc_status_t rpc_wifi_tcpip_service::rpc_tcpip_adapter_set_mac_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t tcpip_if;
    binary_t *mac = NULL;
    mac = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (mac == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&tcpip_if);

    read_binary_t_struct(codec, mac);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_tcpip_adapter_set_mac(tcpip_if, mac);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_tcpip_service_id, krpc_wifi_tcpip_rpc_tcpip_adapter_set_mac_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (mac)
    {
        free_binary_t_struct(mac);
    }
    if (mac)
    {
        erpc_free(mac);
    }

    return err;
}

// Call the correct server shim based on method unique ID.
erpc_status_t rpc_wifi_lwip_service::handleInvocation(uint32_t methodId, uint32_t sequence, Codec * codec, MessageBufferFactory *messageFactory)
{
    switch (methodId)
    {
        case krpc_wifi_lwip_rpc_lwip_accept_id:
            return rpc_lwip_accept_shim(codec, messageFactory, sequence);

        case krpc_wifi_lwip_rpc_lwip_bind_id:
            return rpc_lwip_bind_shim(codec, messageFactory, sequence);

        case krpc_wifi_lwip_rpc_lwip_shutdown_id:
            return rpc_lwip_shutdown_shim(codec, messageFactory, sequence);

        case krpc_wifi_lwip_rpc_lwip_getpeername_id:
            return rpc_lwip_getpeername_shim(codec, messageFactory, sequence);

        case krpc_wifi_lwip_rpc_lwip_getsockname_id:
            return rpc_lwip_getsockname_shim(codec, messageFactory, sequence);

        case krpc_wifi_lwip_rpc_lwip_getsockopt_id:
            return rpc_lwip_getsockopt_shim(codec, messageFactory, sequence);

        case krpc_wifi_lwip_rpc_lwip_setsockopt_id:
            return rpc_lwip_setsockopt_shim(codec, messageFactory, sequence);

        case krpc_wifi_lwip_rpc_lwip_close_id:
            return rpc_lwip_close_shim(codec, messageFactory, sequence);

        case krpc_wifi_lwip_rpc_lwip_connect_id:
            return rpc_lwip_connect_shim(codec, messageFactory, sequence);

        case krpc_wifi_lwip_rpc_lwip_listen_id:
            return rpc_lwip_listen_shim(codec, messageFactory, sequence);

        case krpc_wifi_lwip_rpc_lwip_available_id:
            return rpc_lwip_available_shim(codec, messageFactory, sequence);

        case krpc_wifi_lwip_rpc_lwip_recv_id:
            return rpc_lwip_recv_shim(codec, messageFactory, sequence);

        case krpc_wifi_lwip_rpc_lwip_read_id:
            return rpc_lwip_read_shim(codec, messageFactory, sequence);

        case krpc_wifi_lwip_rpc_lwip_recvfrom_id:
            return rpc_lwip_recvfrom_shim(codec, messageFactory, sequence);

        case krpc_wifi_lwip_rpc_lwip_send_id:
            return rpc_lwip_send_shim(codec, messageFactory, sequence);

        case krpc_wifi_lwip_rpc_lwip_sendmsg_id:
            return rpc_lwip_sendmsg_shim(codec, messageFactory, sequence);

        case krpc_wifi_lwip_rpc_lwip_sendto_id:
            return rpc_lwip_sendto_shim(codec, messageFactory, sequence);

        case krpc_wifi_lwip_rpc_lwip_socket_id:
            return rpc_lwip_socket_shim(codec, messageFactory, sequence);

        case krpc_wifi_lwip_rpc_lwip_write_id:
            return rpc_lwip_write_shim(codec, messageFactory, sequence);

        case krpc_wifi_lwip_rpc_lwip_writev_id:
            return rpc_lwip_writev_shim(codec, messageFactory, sequence);

        case krpc_wifi_lwip_rpc_lwip_select_id:
            return rpc_lwip_select_shim(codec, messageFactory, sequence);

        case krpc_wifi_lwip_rpc_lwip_ioctl_id:
            return rpc_lwip_ioctl_shim(codec, messageFactory, sequence);

        case krpc_wifi_lwip_rpc_lwip_fcntl_id:
            return rpc_lwip_fcntl_shim(codec, messageFactory, sequence);

        case krpc_wifi_lwip_rpc_lwip_errno_id:
            return rpc_lwip_errno_shim(codec, messageFactory, sequence);

        case krpc_wifi_lwip_rpc_netconn_gethostbyname_id:
            return rpc_netconn_gethostbyname_shim(codec, messageFactory, sequence);

        case krpc_wifi_lwip_rpc_dns_gethostbyname_addrtype_id:
            return rpc_dns_gethostbyname_addrtype_shim(codec, messageFactory, sequence);

        default:
            return kErpcStatus_InvalidArgument;
    }
}

// Server shim for rpc_lwip_accept of rpc_wifi_lwip interface.
erpc_status_t rpc_wifi_lwip_service::rpc_lwip_accept_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t s;
    binary_t *addr = NULL;
    addr = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (addr == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    uint32_t addrlen;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&s);

    read_binary_t_struct(codec, addr);

    codec->read(&addrlen);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_lwip_accept(s, addr, &addrlen);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_lwip_service_id, krpc_wifi_lwip_rpc_lwip_accept_id, sequence);

        codec->write(addrlen);

        codec->write(result);

        err = codec->getStatus();
    }

    if (addr)
    {
        free_binary_t_struct(addr);
    }
    if (addr)
    {
        erpc_free(addr);
    }

    return err;
}

// Server shim for rpc_lwip_bind of rpc_wifi_lwip interface.
erpc_status_t rpc_wifi_lwip_service::rpc_lwip_bind_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t s;
    binary_t *name = NULL;
    name = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (name == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    uint32_t namelen;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&s);

    read_binary_t_struct(codec, name);

    codec->read(&namelen);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_lwip_bind(s, name, namelen);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_lwip_service_id, krpc_wifi_lwip_rpc_lwip_bind_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (name)
    {
        free_binary_t_struct(name);
    }
    if (name)
    {
        erpc_free(name);
    }

    return err;
}

// Server shim for rpc_lwip_shutdown of rpc_wifi_lwip interface.
erpc_status_t rpc_wifi_lwip_service::rpc_lwip_shutdown_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t s;
    int32_t how;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&s);

    codec->read(&how);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_lwip_shutdown(s, how);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_lwip_service_id, krpc_wifi_lwip_rpc_lwip_shutdown_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_lwip_getpeername of rpc_wifi_lwip interface.
erpc_status_t rpc_wifi_lwip_service::rpc_lwip_getpeername_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t s;
    binary_t *name = NULL;
    uint32_t namelen;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&s);

    codec->read(&namelen);

    name = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (name == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_lwip_getpeername(s, name, &namelen);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_lwip_service_id, krpc_wifi_lwip_rpc_lwip_getpeername_id, sequence);

        write_binary_t_struct(codec, name);

        codec->write(namelen);

        codec->write(result);

        err = codec->getStatus();
    }

    if (name)
    {
        free_binary_t_struct(name);
    }
    if (name)
    {
        erpc_free(name);
    }

    return err;
}

// Server shim for rpc_lwip_getsockname of rpc_wifi_lwip interface.
erpc_status_t rpc_wifi_lwip_service::rpc_lwip_getsockname_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t s;
    binary_t *name = NULL;
    uint32_t namelen;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&s);

    codec->read(&namelen);

    name = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (name == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_lwip_getsockname(s, name, &namelen);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_lwip_service_id, krpc_wifi_lwip_rpc_lwip_getsockname_id, sequence);

        write_binary_t_struct(codec, name);

        codec->write(namelen);

        codec->write(result);

        err = codec->getStatus();
    }

    if (name)
    {
        free_binary_t_struct(name);
    }
    if (name)
    {
        erpc_free(name);
    }

    return err;
}

// Server shim for rpc_lwip_getsockopt of rpc_wifi_lwip interface.
erpc_status_t rpc_wifi_lwip_service::rpc_lwip_getsockopt_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t s;
    int32_t level;
    int32_t optname;
    binary_t *in_optval = NULL;
    in_optval = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (in_optval == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    binary_t *out_optval = NULL;
    uint32_t optlen;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&s);

    codec->read(&level);

    codec->read(&optname);

    read_binary_t_struct(codec, in_optval);

    codec->read(&optlen);

    out_optval = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (out_optval == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_lwip_getsockopt(s, level, optname, in_optval, out_optval, &optlen);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_lwip_service_id, krpc_wifi_lwip_rpc_lwip_getsockopt_id, sequence);

        write_binary_t_struct(codec, out_optval);

        codec->write(optlen);

        codec->write(result);

        err = codec->getStatus();
    }

    if (in_optval)
    {
        free_binary_t_struct(in_optval);
    }
    if (in_optval)
    {
        erpc_free(in_optval);
    }

    if (out_optval)
    {
        free_binary_t_struct(out_optval);
    }
    if (out_optval)
    {
        erpc_free(out_optval);
    }

    return err;
}

// Server shim for rpc_lwip_setsockopt of rpc_wifi_lwip interface.
erpc_status_t rpc_wifi_lwip_service::rpc_lwip_setsockopt_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t s;
    int32_t level;
    int32_t optname;
    binary_t *optval = NULL;
    optval = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (optval == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    uint32_t optlen;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&s);

    codec->read(&level);

    codec->read(&optname);

    read_binary_t_struct(codec, optval);

    codec->read(&optlen);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_lwip_setsockopt(s, level, optname, optval, optlen);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_lwip_service_id, krpc_wifi_lwip_rpc_lwip_setsockopt_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (optval)
    {
        free_binary_t_struct(optval);
    }
    if (optval)
    {
        erpc_free(optval);
    }

    return err;
}

// Server shim for rpc_lwip_close of rpc_wifi_lwip interface.
erpc_status_t rpc_wifi_lwip_service::rpc_lwip_close_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t s;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&s);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_lwip_close(s);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_lwip_service_id, krpc_wifi_lwip_rpc_lwip_close_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_lwip_connect of rpc_wifi_lwip interface.
erpc_status_t rpc_wifi_lwip_service::rpc_lwip_connect_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t s;
    binary_t *name = NULL;
    name = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (name == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    uint32_t namelen;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&s);

    read_binary_t_struct(codec, name);

    codec->read(&namelen);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_lwip_connect(s, name, namelen);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_lwip_service_id, krpc_wifi_lwip_rpc_lwip_connect_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (name)
    {
        free_binary_t_struct(name);
    }
    if (name)
    {
        erpc_free(name);
    }

    return err;
}

// Server shim for rpc_lwip_listen of rpc_wifi_lwip interface.
erpc_status_t rpc_wifi_lwip_service::rpc_lwip_listen_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t s;
    int32_t backlog;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&s);

    codec->read(&backlog);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_lwip_listen(s, backlog);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_lwip_service_id, krpc_wifi_lwip_rpc_lwip_listen_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_lwip_available of rpc_wifi_lwip interface.
erpc_status_t rpc_wifi_lwip_service::rpc_lwip_available_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t s;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&s);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_lwip_available(s);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_lwip_service_id, krpc_wifi_lwip_rpc_lwip_available_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_lwip_recv of rpc_wifi_lwip interface.
erpc_status_t rpc_wifi_lwip_service::rpc_lwip_recv_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t s;
    binary_t *mem = NULL;
    uint32_t len;
    int32_t flags;
    uint32_t timeout;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&s);

    codec->read(&len);

    codec->read(&flags);

    codec->read(&timeout);

    mem = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (mem == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_lwip_recv(s, mem, len, flags, timeout);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_lwip_service_id, krpc_wifi_lwip_rpc_lwip_recv_id, sequence);

        write_binary_t_struct(codec, mem);

        codec->write(result);

        err = codec->getStatus();
    }

    if (mem)
    {
        free_binary_t_struct(mem);
    }
    if (mem)
    {
        erpc_free(mem);
    }

    return err;
}

// Server shim for rpc_lwip_read of rpc_wifi_lwip interface.
erpc_status_t rpc_wifi_lwip_service::rpc_lwip_read_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t s;
    binary_t *mem = NULL;
    uint32_t len;
    uint32_t timeout;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&s);

    codec->read(&len);

    codec->read(&timeout);

    mem = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (mem == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_lwip_read(s, mem, len, timeout);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_lwip_service_id, krpc_wifi_lwip_rpc_lwip_read_id, sequence);

        write_binary_t_struct(codec, mem);

        codec->write(result);

        err = codec->getStatus();
    }

    if (mem)
    {
        free_binary_t_struct(mem);
    }
    if (mem)
    {
        erpc_free(mem);
    }

    return err;
}

// Server shim for rpc_lwip_recvfrom of rpc_wifi_lwip interface.
erpc_status_t rpc_wifi_lwip_service::rpc_lwip_recvfrom_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t s;
    binary_t *mem = NULL;
    uint32_t len;
    int32_t flags;
    binary_t *from = NULL;
    from = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (from == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    uint32_t fromlen;
    uint32_t timeout;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&s);

    codec->read(&len);

    codec->read(&flags);

    read_binary_t_struct(codec, from);

    codec->read(&fromlen);

    codec->read(&timeout);

    mem = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (mem == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_lwip_recvfrom(s, mem, len, flags, from, &fromlen, timeout);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_lwip_service_id, krpc_wifi_lwip_rpc_lwip_recvfrom_id, sequence);

        write_binary_t_struct(codec, mem);

        codec->write(fromlen);

        codec->write(result);

        err = codec->getStatus();
    }

    if (mem)
    {
        free_binary_t_struct(mem);
    }
    if (mem)
    {
        erpc_free(mem);
    }

    if (from)
    {
        free_binary_t_struct(from);
    }
    if (from)
    {
        erpc_free(from);
    }

    return err;
}

// Server shim for rpc_lwip_send of rpc_wifi_lwip interface.
erpc_status_t rpc_wifi_lwip_service::rpc_lwip_send_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t s;
    binary_t *dataptr = NULL;
    dataptr = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (dataptr == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t flags;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&s);

    read_binary_t_struct(codec, dataptr);

    codec->read(&flags);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_lwip_send(s, dataptr, flags);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_lwip_service_id, krpc_wifi_lwip_rpc_lwip_send_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (dataptr)
    {
        free_binary_t_struct(dataptr);
    }
    if (dataptr)
    {
        erpc_free(dataptr);
    }

    return err;
}

// Server shim for rpc_lwip_sendmsg of rpc_wifi_lwip interface.
erpc_status_t rpc_wifi_lwip_service::rpc_lwip_sendmsg_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t s;
    binary_t *msg_name = NULL;
    msg_name = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (msg_name == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    binary_t *msg_iov = NULL;
    msg_iov = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (msg_iov == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    binary_t *msg_control = NULL;
    msg_control = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (msg_control == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t msg_flags;
    int32_t flags;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&s);

    read_binary_t_struct(codec, msg_name);

    read_binary_t_struct(codec, msg_iov);

    read_binary_t_struct(codec, msg_control);

    codec->read(&msg_flags);

    codec->read(&flags);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_lwip_sendmsg(s, msg_name, msg_iov, msg_control, msg_flags, flags);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_lwip_service_id, krpc_wifi_lwip_rpc_lwip_sendmsg_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (msg_name)
    {
        free_binary_t_struct(msg_name);
    }
    if (msg_name)
    {
        erpc_free(msg_name);
    }

    if (msg_iov)
    {
        free_binary_t_struct(msg_iov);
    }
    if (msg_iov)
    {
        erpc_free(msg_iov);
    }

    if (msg_control)
    {
        free_binary_t_struct(msg_control);
    }
    if (msg_control)
    {
        erpc_free(msg_control);
    }

    return err;
}

// Server shim for rpc_lwip_sendto of rpc_wifi_lwip interface.
erpc_status_t rpc_wifi_lwip_service::rpc_lwip_sendto_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t s;
    binary_t *dataptr = NULL;
    dataptr = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (dataptr == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t flags;
    binary_t *to = NULL;
    to = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (to == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    uint32_t tolen;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&s);

    read_binary_t_struct(codec, dataptr);

    codec->read(&flags);

    read_binary_t_struct(codec, to);

    codec->read(&tolen);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_lwip_sendto(s, dataptr, flags, to, tolen);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_lwip_service_id, krpc_wifi_lwip_rpc_lwip_sendto_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (dataptr)
    {
        free_binary_t_struct(dataptr);
    }
    if (dataptr)
    {
        erpc_free(dataptr);
    }

    if (to)
    {
        free_binary_t_struct(to);
    }
    if (to)
    {
        erpc_free(to);
    }

    return err;
}

// Server shim for rpc_lwip_socket of rpc_wifi_lwip interface.
erpc_status_t rpc_wifi_lwip_service::rpc_lwip_socket_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t domain;
    int32_t l_type;
    int32_t protocol;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&domain);

    codec->read(&l_type);

    codec->read(&protocol);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_lwip_socket(domain, l_type, protocol);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_lwip_service_id, krpc_wifi_lwip_rpc_lwip_socket_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_lwip_write of rpc_wifi_lwip interface.
erpc_status_t rpc_wifi_lwip_service::rpc_lwip_write_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t s;
    binary_t *dataptr = NULL;
    dataptr = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (dataptr == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    uint32_t size;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&s);

    read_binary_t_struct(codec, dataptr);

    codec->read(&size);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_lwip_write(s, dataptr, size);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_lwip_service_id, krpc_wifi_lwip_rpc_lwip_write_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (dataptr)
    {
        free_binary_t_struct(dataptr);
    }
    if (dataptr)
    {
        erpc_free(dataptr);
    }

    return err;
}

// Server shim for rpc_lwip_writev of rpc_wifi_lwip interface.
erpc_status_t rpc_wifi_lwip_service::rpc_lwip_writev_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t s;
    binary_t *iov = NULL;
    iov = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (iov == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t iovcnt;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&s);

    read_binary_t_struct(codec, iov);

    codec->read(&iovcnt);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_lwip_writev(s, iov, iovcnt);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_lwip_service_id, krpc_wifi_lwip_rpc_lwip_writev_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (iov)
    {
        free_binary_t_struct(iov);
    }
    if (iov)
    {
        erpc_free(iov);
    }

    return err;
}

// Server shim for rpc_lwip_select of rpc_wifi_lwip interface.
erpc_status_t rpc_wifi_lwip_service::rpc_lwip_select_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t maxfdp1;
    binary_t *readset = NULL;
    binary_t *writeset = NULL;
    binary_t *exceptset = NULL;
    binary_t *timeout = NULL;
    bool isNull;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&maxfdp1);

    codec->readNullFlag(&isNull);
    if (!isNull)
    {
        readset = (binary_t *) erpc_malloc(sizeof(binary_t));
        if (readset == NULL)
        {
            codec->updateStatus(kErpcStatus_MemoryError);
        }
        read_binary_t_struct(codec, readset);
    }
    else
    {
        readset = NULL;
    }

    codec->readNullFlag(&isNull);
    if (!isNull)
    {
        writeset = (binary_t *) erpc_malloc(sizeof(binary_t));
        if (writeset == NULL)
        {
            codec->updateStatus(kErpcStatus_MemoryError);
        }
        read_binary_t_struct(codec, writeset);
    }
    else
    {
        writeset = NULL;
    }

    codec->readNullFlag(&isNull);
    if (!isNull)
    {
        exceptset = (binary_t *) erpc_malloc(sizeof(binary_t));
        if (exceptset == NULL)
        {
            codec->updateStatus(kErpcStatus_MemoryError);
        }
        read_binary_t_struct(codec, exceptset);
    }
    else
    {
        exceptset = NULL;
    }

    codec->readNullFlag(&isNull);
    if (!isNull)
    {
        timeout = (binary_t *) erpc_malloc(sizeof(binary_t));
        if (timeout == NULL)
        {
            codec->updateStatus(kErpcStatus_MemoryError);
        }
        read_binary_t_struct(codec, timeout);
    }
    else
    {
        timeout = NULL;
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_lwip_select(maxfdp1, readset, writeset, exceptset, timeout);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_lwip_service_id, krpc_wifi_lwip_rpc_lwip_select_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (readset)
    {
        free_binary_t_struct(readset);
    }
    if (readset)
    {
        erpc_free(readset);
    }

    if (writeset)
    {
        free_binary_t_struct(writeset);
    }
    if (writeset)
    {
        erpc_free(writeset);
    }

    if (exceptset)
    {
        free_binary_t_struct(exceptset);
    }
    if (exceptset)
    {
        erpc_free(exceptset);
    }

    if (timeout)
    {
        free_binary_t_struct(timeout);
    }
    if (timeout)
    {
        erpc_free(timeout);
    }

    return err;
}

// Server shim for rpc_lwip_ioctl of rpc_wifi_lwip interface.
erpc_status_t rpc_wifi_lwip_service::rpc_lwip_ioctl_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t s;
    uint32_t cmd;
    binary_t *in_argp = NULL;
    in_argp = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (in_argp == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    binary_t *out_argp = NULL;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&s);

    codec->read(&cmd);

    read_binary_t_struct(codec, in_argp);

    out_argp = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (out_argp == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_lwip_ioctl(s, cmd, in_argp, out_argp);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_lwip_service_id, krpc_wifi_lwip_rpc_lwip_ioctl_id, sequence);

        write_binary_t_struct(codec, out_argp);

        codec->write(result);

        err = codec->getStatus();
    }

    if (in_argp)
    {
        free_binary_t_struct(in_argp);
    }
    if (in_argp)
    {
        erpc_free(in_argp);
    }

    if (out_argp)
    {
        free_binary_t_struct(out_argp);
    }
    if (out_argp)
    {
        erpc_free(out_argp);
    }

    return err;
}

// Server shim for rpc_lwip_fcntl of rpc_wifi_lwip interface.
erpc_status_t rpc_wifi_lwip_service::rpc_lwip_fcntl_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t s;
    int32_t cmd;
    int32_t val;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&s);

    codec->read(&cmd);

    codec->read(&val);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_lwip_fcntl(s, cmd, val);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_lwip_service_id, krpc_wifi_lwip_rpc_lwip_fcntl_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_lwip_errno of rpc_wifi_lwip interface.
erpc_status_t rpc_wifi_lwip_service::rpc_lwip_errno_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_lwip_errno();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_lwip_service_id, krpc_wifi_lwip_rpc_lwip_errno_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_netconn_gethostbyname of rpc_wifi_lwip interface.
erpc_status_t rpc_wifi_lwip_service::rpc_netconn_gethostbyname_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    char * name = NULL;
    binary_t *addr = NULL;
    int8_t result;

    // startReadMessage() was already called before this shim was invoked.

    uint32_t name_len;
    char * name_local;
    codec->readString(&name_len, &name_local);
    name = (char *) erpc_malloc((name_len + 1) * sizeof(char));
    if (name == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    else
    {
        memcpy(name, name_local, name_len);
        (name)[name_len] = 0;
    }

    addr = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (addr == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_netconn_gethostbyname(name, addr);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_lwip_service_id, krpc_wifi_lwip_rpc_netconn_gethostbyname_id, sequence);

        write_binary_t_struct(codec, addr);

        codec->write(result);

        err = codec->getStatus();
    }

    if (name)
    {
        erpc_free(name);
    }

    if (addr)
    {
        free_binary_t_struct(addr);
    }
    if (addr)
    {
        erpc_free(addr);
    }

    return err;
}

// Server shim for rpc_dns_gethostbyname_addrtype of rpc_wifi_lwip interface.
erpc_status_t rpc_wifi_lwip_service::rpc_dns_gethostbyname_addrtype_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    char * hostname = NULL;
    binary_t *addr = NULL;
    uint32_t found;
    binary_t *callback_arg = NULL;
    uint8_t dns_addrtype;
    bool isNull;
    int8_t result;

    // startReadMessage() was already called before this shim was invoked.

    uint32_t hostname_len;
    char * hostname_local;
    codec->readString(&hostname_len, &hostname_local);
    hostname = (char *) erpc_malloc((hostname_len + 1) * sizeof(char));
    if (hostname == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    else
    {
        memcpy(hostname, hostname_local, hostname_len);
        (hostname)[hostname_len] = 0;
    }

    codec->read(&found);

    codec->readNullFlag(&isNull);
    if (!isNull)
    {
        callback_arg = (binary_t *) erpc_malloc(sizeof(binary_t));
        if (callback_arg == NULL)
        {
            codec->updateStatus(kErpcStatus_MemoryError);
        }
        read_binary_t_struct(codec, callback_arg);
    }
    else
    {
        callback_arg = NULL;
    }

    codec->read(&dns_addrtype);

    addr = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (addr == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_dns_gethostbyname_addrtype(hostname, addr, found, callback_arg, dns_addrtype);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_lwip_service_id, krpc_wifi_lwip_rpc_dns_gethostbyname_addrtype_id, sequence);

        write_binary_t_struct(codec, addr);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Call the correct server shim based on method unique ID.
erpc_status_t rpc_wifi_mbedtls_service::handleInvocation(uint32_t methodId, uint32_t sequence, Codec * codec, MessageBufferFactory *messageFactory)
{
    switch (methodId)
    {
        case krpc_wifi_mbedtls_rpc_wifi_ssl_client_create_id:
            return rpc_wifi_ssl_client_create_shim(codec, messageFactory, sequence);

        case krpc_wifi_mbedtls_rpc_wifi_ssl_client_destroy_id:
            return rpc_wifi_ssl_client_destroy_shim(codec, messageFactory, sequence);

        case krpc_wifi_mbedtls_rpc_wifi_ssl_init_id:
            return rpc_wifi_ssl_init_shim(codec, messageFactory, sequence);

        case krpc_wifi_mbedtls_rpc_wifi_ssl_set_socket_id:
            return rpc_wifi_ssl_set_socket_shim(codec, messageFactory, sequence);

        case krpc_wifi_mbedtls_rpc_wifi_ssl_set_timeout_id:
            return rpc_wifi_ssl_set_timeout_shim(codec, messageFactory, sequence);

        case krpc_wifi_mbedtls_rpc_wifi_ssl_get_socket_id:
            return rpc_wifi_ssl_get_socket_shim(codec, messageFactory, sequence);

        case krpc_wifi_mbedtls_rpc_wifi_ssl_get_timeout_id:
            return rpc_wifi_ssl_get_timeout_shim(codec, messageFactory, sequence);

        case krpc_wifi_mbedtls_rpc_wifi_ssl_set_rootCA_id:
            return rpc_wifi_ssl_set_rootCA_shim(codec, messageFactory, sequence);

        case krpc_wifi_mbedtls_rpc_wifi_ssl_get_rootCA_id:
            return rpc_wifi_ssl_get_rootCA_shim(codec, messageFactory, sequence);

        case krpc_wifi_mbedtls_rpc_wifi_ssl_set_cliCert_id:
            return rpc_wifi_ssl_set_cliCert_shim(codec, messageFactory, sequence);

        case krpc_wifi_mbedtls_rpc_wifi_ssl_get_cliCert_id:
            return rpc_wifi_ssl_get_cliCert_shim(codec, messageFactory, sequence);

        case krpc_wifi_mbedtls_rpc_wifi_ssl_set_cliKey_id:
            return rpc_wifi_ssl_set_cliKey_shim(codec, messageFactory, sequence);

        case krpc_wifi_mbedtls_rpc_wifi_ssl_get_cliKey_id:
            return rpc_wifi_ssl_get_cliKey_shim(codec, messageFactory, sequence);

        case krpc_wifi_mbedtls_rpc_wifi_ssl_set_pskIdent_id:
            return rpc_wifi_ssl_set_pskIdent_shim(codec, messageFactory, sequence);

        case krpc_wifi_mbedtls_rpc_wifi_ssl_get_pskIdent_id:
            return rpc_wifi_ssl_get_pskIdent_shim(codec, messageFactory, sequence);

        case krpc_wifi_mbedtls_rpc_wifi_ssl_set_psKey_id:
            return rpc_wifi_ssl_set_psKey_shim(codec, messageFactory, sequence);

        case krpc_wifi_mbedtls_rpc_wifi_ssl_get_psKey_id:
            return rpc_wifi_ssl_get_psKey_shim(codec, messageFactory, sequence);

        case krpc_wifi_mbedtls_rpc_wifi_start_ssl_client_id:
            return rpc_wifi_start_ssl_client_shim(codec, messageFactory, sequence);

        case krpc_wifi_mbedtls_rpc_wifi_stop_ssl_socket_id:
            return rpc_wifi_stop_ssl_socket_shim(codec, messageFactory, sequence);

        case krpc_wifi_mbedtls_rpc_wifi_data_to_read_id:
            return rpc_wifi_data_to_read_shim(codec, messageFactory, sequence);

        case krpc_wifi_mbedtls_rpc_wifi_send_ssl_data_id:
            return rpc_wifi_send_ssl_data_shim(codec, messageFactory, sequence);

        case krpc_wifi_mbedtls_rpc_wifi_get_ssl_receive_id:
            return rpc_wifi_get_ssl_receive_shim(codec, messageFactory, sequence);

        case krpc_wifi_mbedtls_rpc_wifi_verify_ssl_fingerprint_id:
            return rpc_wifi_verify_ssl_fingerprint_shim(codec, messageFactory, sequence);

        case krpc_wifi_mbedtls_rpc_wifi_verify_ssl_dn_id:
            return rpc_wifi_verify_ssl_dn_shim(codec, messageFactory, sequence);

        case krpc_wifi_mbedtls_rpc_wifi_ssl_strerror_id:
            return rpc_wifi_ssl_strerror_shim(codec, messageFactory, sequence);

        default:
            return kErpcStatus_InvalidArgument;
    }
}

// Server shim for rpc_wifi_ssl_client_create of rpc_wifi_mbedtls interface.
erpc_status_t rpc_wifi_mbedtls_service::rpc_wifi_ssl_client_create_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_ssl_client_create();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_mbedtls_service_id, krpc_wifi_mbedtls_rpc_wifi_ssl_client_create_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_ssl_client_destroy of rpc_wifi_mbedtls interface.
erpc_status_t rpc_wifi_mbedtls_service::rpc_wifi_ssl_client_destroy_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t ssl_client;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&ssl_client);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        rpc_wifi_ssl_client_destroy(ssl_client);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_mbedtls_service_id, krpc_wifi_mbedtls_rpc_wifi_ssl_client_destroy_id, sequence);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_ssl_init of rpc_wifi_mbedtls interface.
erpc_status_t rpc_wifi_mbedtls_service::rpc_wifi_ssl_init_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t ssl_client;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&ssl_client);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        rpc_wifi_ssl_init(ssl_client);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_mbedtls_service_id, krpc_wifi_mbedtls_rpc_wifi_ssl_init_id, sequence);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_ssl_set_socket of rpc_wifi_mbedtls interface.
erpc_status_t rpc_wifi_mbedtls_service::rpc_wifi_ssl_set_socket_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t ssl_client;
    int32_t socket;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&ssl_client);

    codec->read(&socket);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        rpc_wifi_ssl_set_socket(ssl_client, socket);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_mbedtls_service_id, krpc_wifi_mbedtls_rpc_wifi_ssl_set_socket_id, sequence);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_ssl_set_timeout of rpc_wifi_mbedtls interface.
erpc_status_t rpc_wifi_mbedtls_service::rpc_wifi_ssl_set_timeout_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t ssl_client;
    uint32_t timeout;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&ssl_client);

    codec->read(&timeout);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        rpc_wifi_ssl_set_timeout(ssl_client, timeout);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_mbedtls_service_id, krpc_wifi_mbedtls_rpc_wifi_ssl_set_timeout_id, sequence);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_ssl_get_socket of rpc_wifi_mbedtls interface.
erpc_status_t rpc_wifi_mbedtls_service::rpc_wifi_ssl_get_socket_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t ssl_client;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&ssl_client);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_ssl_get_socket(ssl_client);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_mbedtls_service_id, krpc_wifi_mbedtls_rpc_wifi_ssl_get_socket_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_ssl_get_timeout of rpc_wifi_mbedtls interface.
erpc_status_t rpc_wifi_mbedtls_service::rpc_wifi_ssl_get_timeout_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t ssl_client;
    uint32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&ssl_client);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_ssl_get_timeout(ssl_client);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_mbedtls_service_id, krpc_wifi_mbedtls_rpc_wifi_ssl_get_timeout_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_ssl_set_rootCA of rpc_wifi_mbedtls interface.
erpc_status_t rpc_wifi_mbedtls_service::rpc_wifi_ssl_set_rootCA_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t ssl_client;
    char * rootCABuff = NULL;
    uint32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&ssl_client);

    uint32_t rootCABuff_len;
    char * rootCABuff_local;
    codec->readString(&rootCABuff_len, &rootCABuff_local);
    rootCABuff = (char *) erpc_malloc((rootCABuff_len + 1) * sizeof(char));
    if (rootCABuff == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    else
    {
        memcpy(rootCABuff, rootCABuff_local, rootCABuff_len);
        (rootCABuff)[rootCABuff_len] = 0;
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_ssl_set_rootCA(ssl_client, rootCABuff);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_mbedtls_service_id, krpc_wifi_mbedtls_rpc_wifi_ssl_set_rootCA_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_ssl_get_rootCA of rpc_wifi_mbedtls interface.
erpc_status_t rpc_wifi_mbedtls_service::rpc_wifi_ssl_get_rootCA_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t ssl_client;
    char * rootCABuff = NULL;
    bool isNull;
    uint32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&ssl_client);

    codec->readNullFlag(&isNull);
    if (!isNull)
    {
        rootCABuff = (char *) erpc_malloc((3092 + 1) * sizeof(char));
        if (rootCABuff == NULL)
        {
            codec->updateStatus(kErpcStatus_MemoryError);
        }
        else
        {
            rootCABuff[3092] = '\0';
        }
    }
    else
    {
        rootCABuff = NULL;
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_ssl_get_rootCA(ssl_client, rootCABuff);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_mbedtls_service_id, krpc_wifi_mbedtls_rpc_wifi_ssl_get_rootCA_id, sequence);

        if (rootCABuff != NULL)
        {
            codec->writeString(strlen(rootCABuff), rootCABuff);
        }

        codec->write(result);

        err = codec->getStatus();
    }

    if (rootCABuff)
    {
        erpc_free(rootCABuff);
    }

    return err;
}

// Server shim for rpc_wifi_ssl_set_cliCert of rpc_wifi_mbedtls interface.
erpc_status_t rpc_wifi_mbedtls_service::rpc_wifi_ssl_set_cliCert_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t ssl_client;
    char * cli_cert = NULL;
    uint32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&ssl_client);

    uint32_t cli_cert_len;
    char * cli_cert_local;
    codec->readString(&cli_cert_len, &cli_cert_local);
    cli_cert = (char *) erpc_malloc((cli_cert_len + 1) * sizeof(char));
    if (cli_cert == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    else
    {
        memcpy(cli_cert, cli_cert_local, cli_cert_len);
        (cli_cert)[cli_cert_len] = 0;
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_ssl_set_cliCert(ssl_client, cli_cert);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_mbedtls_service_id, krpc_wifi_mbedtls_rpc_wifi_ssl_set_cliCert_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_ssl_get_cliCert of rpc_wifi_mbedtls interface.
erpc_status_t rpc_wifi_mbedtls_service::rpc_wifi_ssl_get_cliCert_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t ssl_client;
    char * cli_cert = NULL;
    bool isNull;
    uint32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&ssl_client);

    codec->readNullFlag(&isNull);
    if (!isNull)
    {
        uint32_t cli_cert_len;
        char * cli_cert_local;
        codec->readString(&cli_cert_len, &cli_cert_local);
        cli_cert = (char *) erpc_malloc((2048 + 1) * sizeof(char));
        if (cli_cert == NULL)
        {
            codec->updateStatus(kErpcStatus_MemoryError);
        }
        else
        {
            memcpy(cli_cert, cli_cert_local, cli_cert_len);
            (cli_cert)[cli_cert_len] = 0;
        }
    }
    else
    {
        cli_cert = NULL;
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_ssl_get_cliCert(ssl_client, cli_cert);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_mbedtls_service_id, krpc_wifi_mbedtls_rpc_wifi_ssl_get_cliCert_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (cli_cert)
    {
        erpc_free(cli_cert);
    }

    return err;
}

// Server shim for rpc_wifi_ssl_set_cliKey of rpc_wifi_mbedtls interface.
erpc_status_t rpc_wifi_mbedtls_service::rpc_wifi_ssl_set_cliKey_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t ssl_client;
    char * cli_key = NULL;
    uint32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&ssl_client);

    uint32_t cli_key_len;
    char * cli_key_local;
    codec->readString(&cli_key_len, &cli_key_local);
    cli_key = (char *) erpc_malloc((cli_key_len + 1) * sizeof(char));
    if (cli_key == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    else
    {
        memcpy(cli_key, cli_key_local, cli_key_len);
        (cli_key)[cli_key_len] = 0;
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_ssl_set_cliKey(ssl_client, cli_key);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_mbedtls_service_id, krpc_wifi_mbedtls_rpc_wifi_ssl_set_cliKey_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_ssl_get_cliKey of rpc_wifi_mbedtls interface.
erpc_status_t rpc_wifi_mbedtls_service::rpc_wifi_ssl_get_cliKey_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t ssl_client;
    char * cli_key = NULL;
    bool isNull;
    uint32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&ssl_client);

    codec->readNullFlag(&isNull);
    if (!isNull)
    {
        uint32_t cli_key_len;
        char * cli_key_local;
        codec->readString(&cli_key_len, &cli_key_local);
        cli_key = (char *) erpc_malloc((2048 + 1) * sizeof(char));
        if (cli_key == NULL)
        {
            codec->updateStatus(kErpcStatus_MemoryError);
        }
        else
        {
            memcpy(cli_key, cli_key_local, cli_key_len);
            (cli_key)[cli_key_len] = 0;
        }
    }
    else
    {
        cli_key = NULL;
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_ssl_get_cliKey(ssl_client, cli_key);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_mbedtls_service_id, krpc_wifi_mbedtls_rpc_wifi_ssl_get_cliKey_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (cli_key)
    {
        erpc_free(cli_key);
    }

    return err;
}

// Server shim for rpc_wifi_ssl_set_pskIdent of rpc_wifi_mbedtls interface.
erpc_status_t rpc_wifi_mbedtls_service::rpc_wifi_ssl_set_pskIdent_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t ssl_client;
    char * pskIdent = NULL;
    uint32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&ssl_client);

    uint32_t pskIdent_len;
    char * pskIdent_local;
    codec->readString(&pskIdent_len, &pskIdent_local);
    pskIdent = (char *) erpc_malloc((pskIdent_len + 1) * sizeof(char));
    if (pskIdent == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    else
    {
        memcpy(pskIdent, pskIdent_local, pskIdent_len);
        (pskIdent)[pskIdent_len] = 0;
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_ssl_set_pskIdent(ssl_client, pskIdent);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_mbedtls_service_id, krpc_wifi_mbedtls_rpc_wifi_ssl_set_pskIdent_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_ssl_get_pskIdent of rpc_wifi_mbedtls interface.
erpc_status_t rpc_wifi_mbedtls_service::rpc_wifi_ssl_get_pskIdent_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t ssl_client;
    char * pskIdent = NULL;
    bool isNull;
    uint32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&ssl_client);

    codec->readNullFlag(&isNull);
    if (!isNull)
    {
        uint32_t pskIdent_len;
        char * pskIdent_local;
        codec->readString(&pskIdent_len, &pskIdent_local);
        pskIdent = (char *) erpc_malloc((256 + 1) * sizeof(char));
        if (pskIdent == NULL)
        {
            codec->updateStatus(kErpcStatus_MemoryError);
        }
        else
        {
            memcpy(pskIdent, pskIdent_local, pskIdent_len);
            (pskIdent)[pskIdent_len] = 0;
        }
    }
    else
    {
        pskIdent = NULL;
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_ssl_get_pskIdent(ssl_client, pskIdent);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_mbedtls_service_id, krpc_wifi_mbedtls_rpc_wifi_ssl_get_pskIdent_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (pskIdent)
    {
        erpc_free(pskIdent);
    }

    return err;
}

// Server shim for rpc_wifi_ssl_set_psKey of rpc_wifi_mbedtls interface.
erpc_status_t rpc_wifi_mbedtls_service::rpc_wifi_ssl_set_psKey_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t ssl_client;
    char * psKey = NULL;
    uint32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&ssl_client);

    uint32_t psKey_len;
    char * psKey_local;
    codec->readString(&psKey_len, &psKey_local);
    psKey = (char *) erpc_malloc((psKey_len + 1) * sizeof(char));
    if (psKey == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    else
    {
        memcpy(psKey, psKey_local, psKey_len);
        (psKey)[psKey_len] = 0;
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_ssl_set_psKey(ssl_client, psKey);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_mbedtls_service_id, krpc_wifi_mbedtls_rpc_wifi_ssl_set_psKey_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_ssl_get_psKey of rpc_wifi_mbedtls interface.
erpc_status_t rpc_wifi_mbedtls_service::rpc_wifi_ssl_get_psKey_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t ssl_client;
    char * psKey = NULL;
    bool isNull;
    uint32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&ssl_client);

    codec->readNullFlag(&isNull);
    if (!isNull)
    {
        uint32_t psKey_len;
        char * psKey_local;
        codec->readString(&psKey_len, &psKey_local);
        psKey = (char *) erpc_malloc((256 + 1) * sizeof(char));
        if (psKey == NULL)
        {
            codec->updateStatus(kErpcStatus_MemoryError);
        }
        else
        {
            memcpy(psKey, psKey_local, psKey_len);
            (psKey)[psKey_len] = 0;
        }
    }
    else
    {
        psKey = NULL;
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_ssl_get_psKey(ssl_client, psKey);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_mbedtls_service_id, krpc_wifi_mbedtls_rpc_wifi_ssl_get_psKey_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (psKey)
    {
        erpc_free(psKey);
    }

    return err;
}

// Server shim for rpc_wifi_start_ssl_client of rpc_wifi_mbedtls interface.
erpc_status_t rpc_wifi_mbedtls_service::rpc_wifi_start_ssl_client_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t ssl_client;
    char * host = NULL;
    uint32_t port;
    int32_t timeout;
    bool isNull;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&ssl_client);

    codec->readNullFlag(&isNull);
    if (!isNull)
    {
        uint32_t host_len;
        char * host_local;
        codec->readString(&host_len, &host_local);
        host = (char *) erpc_malloc((host_len + 1) * sizeof(char));
        if (host == NULL)
        {
            codec->updateStatus(kErpcStatus_MemoryError);
        }
        else
        {
            memcpy(host, host_local, host_len);
            (host)[host_len] = 0;
        }
    }
    else
    {
        host = NULL;
    }

    codec->read(&port);

    codec->read(&timeout);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_start_ssl_client(ssl_client, host, port, timeout);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_mbedtls_service_id, krpc_wifi_mbedtls_rpc_wifi_start_ssl_client_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (host)
    {
        erpc_free(host);
    }

    return err;
}

// Server shim for rpc_wifi_stop_ssl_socket of rpc_wifi_mbedtls interface.
erpc_status_t rpc_wifi_mbedtls_service::rpc_wifi_stop_ssl_socket_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t ssl_client;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&ssl_client);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        rpc_wifi_stop_ssl_socket(ssl_client);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_mbedtls_service_id, krpc_wifi_mbedtls_rpc_wifi_stop_ssl_socket_id, sequence);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_data_to_read of rpc_wifi_mbedtls interface.
erpc_status_t rpc_wifi_mbedtls_service::rpc_wifi_data_to_read_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t ssl_client;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&ssl_client);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_data_to_read(ssl_client);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_mbedtls_service_id, krpc_wifi_mbedtls_rpc_wifi_data_to_read_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for rpc_wifi_send_ssl_data of rpc_wifi_mbedtls interface.
erpc_status_t rpc_wifi_mbedtls_service::rpc_wifi_send_ssl_data_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t ssl_client;
    binary_t *data = NULL;
    data = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (data == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    uint16_t len;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&ssl_client);

    read_binary_t_struct(codec, data);

    codec->read(&len);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_send_ssl_data(ssl_client, data, len);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_mbedtls_service_id, krpc_wifi_mbedtls_rpc_wifi_send_ssl_data_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (data)
    {
        free_binary_t_struct(data);
    }
    if (data)
    {
        erpc_free(data);
    }

    return err;
}

// Server shim for rpc_wifi_get_ssl_receive of rpc_wifi_mbedtls interface.
erpc_status_t rpc_wifi_mbedtls_service::rpc_wifi_get_ssl_receive_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t ssl_client;
    binary_t *data = NULL;
    int32_t length;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&ssl_client);

    codec->read(&length);

    data = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (data == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_get_ssl_receive(ssl_client, data, length);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_mbedtls_service_id, krpc_wifi_mbedtls_rpc_wifi_get_ssl_receive_id, sequence);

        write_binary_t_struct(codec, data);

        codec->write(result);

        err = codec->getStatus();
    }

    if (data)
    {
        free_binary_t_struct(data);
    }
    if (data)
    {
        erpc_free(data);
    }

    return err;
}

// Server shim for rpc_wifi_verify_ssl_fingerprint of rpc_wifi_mbedtls interface.
erpc_status_t rpc_wifi_mbedtls_service::rpc_wifi_verify_ssl_fingerprint_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t ssl_client;
    char * fp = NULL;
    char * domain_name = NULL;
    bool result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&ssl_client);

    uint32_t fp_len;
    char * fp_local;
    codec->readString(&fp_len, &fp_local);
    fp = (char *) erpc_malloc((fp_len + 1) * sizeof(char));
    if (fp == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    else
    {
        memcpy(fp, fp_local, fp_len);
        (fp)[fp_len] = 0;
    }

    uint32_t domain_name_len;
    char * domain_name_local;
    codec->readString(&domain_name_len, &domain_name_local);
    domain_name = (char *) erpc_malloc((domain_name_len + 1) * sizeof(char));
    if (domain_name == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    else
    {
        memcpy(domain_name, domain_name_local, domain_name_len);
        (domain_name)[domain_name_len] = 0;
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_verify_ssl_fingerprint(ssl_client, fp, domain_name);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_mbedtls_service_id, krpc_wifi_mbedtls_rpc_wifi_verify_ssl_fingerprint_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (fp)
    {
        erpc_free(fp);
    }

    if (domain_name)
    {
        erpc_free(domain_name);
    }

    return err;
}

// Server shim for rpc_wifi_verify_ssl_dn of rpc_wifi_mbedtls interface.
erpc_status_t rpc_wifi_mbedtls_service::rpc_wifi_verify_ssl_dn_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t ssl_client;
    char * domain_name = NULL;
    bool result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&ssl_client);

    uint32_t domain_name_len;
    char * domain_name_local;
    codec->readString(&domain_name_len, &domain_name_local);
    domain_name = (char *) erpc_malloc((domain_name_len + 1) * sizeof(char));
    if (domain_name == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    else
    {
        memcpy(domain_name, domain_name_local, domain_name_len);
        (domain_name)[domain_name_len] = 0;
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = rpc_wifi_verify_ssl_dn(ssl_client, domain_name);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_mbedtls_service_id, krpc_wifi_mbedtls_rpc_wifi_verify_ssl_dn_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (domain_name)
    {
        erpc_free(domain_name);
    }

    return err;
}

// Server shim for rpc_wifi_ssl_strerror of rpc_wifi_mbedtls interface.
erpc_status_t rpc_wifi_mbedtls_service::rpc_wifi_ssl_strerror_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t errnum;
    binary_t *buffer = NULL;
    uint32_t buflen;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&errnum);

    codec->read(&buflen);

    buffer = (binary_t *) erpc_malloc(sizeof(binary_t));
    if (buffer == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        rpc_wifi_ssl_strerror(errnum, buffer, buflen);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, krpc_wifi_mbedtls_service_id, krpc_wifi_mbedtls_rpc_wifi_ssl_strerror_id, sequence);

        write_binary_t_struct(codec, buffer);

        err = codec->getStatus();
    }

    if (buffer)
    {
        free_binary_t_struct(buffer);
    }
    if (buffer)
    {
        erpc_free(buffer);
    }

    return err;
}

erpc_service_t create_rpc_wifi_drv_service()
{
    s_rpc_wifi_drv_service.construct();
    return s_rpc_wifi_drv_service.get();
}

void destroy_rpc_wifi_drv_service()
{
    s_rpc_wifi_drv_service.destroy();
}

erpc_service_t create_rpc_wifi_tcpip_service()
{
    s_rpc_wifi_tcpip_service.construct();
    return s_rpc_wifi_tcpip_service.get();
}

void destroy_rpc_wifi_tcpip_service()
{
    s_rpc_wifi_tcpip_service.destroy();
}

erpc_service_t create_rpc_wifi_lwip_service()
{
    s_rpc_wifi_lwip_service.construct();
    return s_rpc_wifi_lwip_service.get();
}

void destroy_rpc_wifi_lwip_service()
{
    s_rpc_wifi_lwip_service.destroy();
}

erpc_service_t create_rpc_wifi_mbedtls_service()
{
    s_rpc_wifi_mbedtls_service.construct();
    return s_rpc_wifi_mbedtls_service.get();
}

void destroy_rpc_wifi_mbedtls_service()
{
    s_rpc_wifi_mbedtls_service.destroy();
}
